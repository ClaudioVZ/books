<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>Practical</title>
<link href="stylesheet.css" type="text/css" rel="stylesheet" />
</head>
<body>
<h1>Practical</h1>
<p>We're going to use Sinatra in a similar manner to how we used Express in the last chapter. It will power a RESTful API supporting CRUD operations. Together with a MongoDB data store, this will allow us to easily persist data (todo items) whilst ensuring they are stored in a database. If you've read the previous chapter or have gone through any of the Todo examples covered so far, you will find this surprisingly straight-forward.</p><p>Remember that the default Todo example included with Backbone.js already persists data, although it does this via a localStorage adapter. Luckily there aren't a great deal of changes needed to switch over to using our Sinatra-based API. Let's briefly review the code that will be powering the CRUD operations for this sections practical, as we go course won't be starting off with a near-complete base for most of our real world applications.</p><h3 id="installing-the-prerequisites"><a id="preq">Installing The Prerequisites</a></h3><h4 id="ruby">Ruby</h4><p>If using OSX or Linux, Ruby may be one of a number of open-source packages that come pre-installed and you can skip over to the next paragraph. In case you would like to check if check if you have Ruby installed, open up the terminal prompt and type:</p><p><code>$ ruby -v</code></p><p>The output of this will either be the version of Ruby installed or an error complaining that Ruby wasn't found.</p><p>Should you need to install Ruby manually (e.g for an operating system such as Windows), you can do so by downloading the latest version from http://www.ruby-lang.org/en/downloads/. Alternatively, (RVM)[http://beginrescueend.com/rvm/install/] (Ruby Version Manager) is a command-line tool that allows you to easily install and manage multiple ruby environments with ease.</p><h4 id="ruby-gems">Ruby Gems</h4><p>Next, we will need to install Ruby Gems. Gems are a standard way to package programs or libraries written in Ruby and with Ruby Gems it's possible to install additional dependencies for Ruby applications very easily.</p><p>On OSX, Linux or Windows go to <a href="http://rubyforge.org/projects/rubygems">http://rubyforge.org/projects/rubygems</a> and download the latest version of Ruby Gems. Once downloaded, open up a terminal, navigate to the folder where this resides and enter:</p><pre><code>$&gt; tar xzvf rubygems.tgz
$&gt; cd rubygems
$&gt; sudo ruby setup.rb</code></pre><p>There will likely be a version number included in your download and you should make sure to include this when tying the above. Finally, a symlink (symbolic link) to tie everything togther should be fun as follows:</p><p><code>$ sudo ln -s /usr/bin/gem1.8.17 /usr/bin/gem</code></p><p>To check that Ruby Gems has been correctly installed, type the following into your terminal:</p><pre><code>$ gem -v</code></pre><h4 id="sinatra">Sinatra</h4><p>With Ruby Gems setup, we can now easily install Sinatra. For Linux or OSX type this in your terminal:</p><p><code>$ sudo gem install sinatra</code></p><p>and if you're on Windows, enter the following at a command prompt:</p><p><code>c:\\ &gt; gem install sinatra</code></p><h4 id="haml">Haml</h4><p>As with other DSLs and frameworks, Sinatra supports a wide range of different templating engines. <a href="http://www.ruby-doc.org/stdlib/libdoc/erb/rdoc/classes/ERB.html">ERB</a> is the one most often recommended by the Sinatra camp, however as a part of this chapter, we're going to explore the use of <a href="http://haml.hamptoncatlin.com/">Haml</a> to define our application templates.</p><p>Haml stands for HTML Abstractional Markup Language and is a lightweight markup language abstraction that can be used to describe HTML without the need to use traditional markup language semantics (such as opening and closing tags).</p><p>Installing Haml can be done in just a line using Ruby Gems as follows:</p><p><code>$ gem install haml</code></p><h4 id="mongodb">MongoDB</h4><p>If you haven't already downloaded and installed MongoDB from an earlier chapter, please <a href="http://www.mongodb.org/downloads">do so</a> now. With Ruby Gems, Mongo can be installed in just one line:</p><p><code>$ gem install mongodb</code></p><p>We now require two further steps to get everything up and running.</p><h5 id="data-directories">1.Data directories</h5><p>MongoDB stores data in the bin/data/db folder but won't actually create this directory for you. Navigate to where you've downloaded and extracted Mongo and run the following from terminal:</p><pre><code>sudo mkdir -p /data/db/
sudo chown `id -u` /data/db</code></pre><h5 id="running-and-connecting-to-your-server">2.Running and connecting to your server</h5><p>Once this is done, open up two terminal windows.</p><p>In the first, cd to your MongoDB bin directory or type in the complete path to it. You'll need to start mongod.</p><pre><code>$ ./bin/mongod</code></pre><p>Finally, in the second terminal, start the mongo shell which will connect up to localhost by default.</p><pre><code>$ ./bin/mongo</code></pre><h4 id="mongodb-ruby-driver">MongoDB Ruby Driver</h4><p>As we'll be using the <a href="https://github.com/mongodb/mongo-ruby-driver">MongoDB Ruby Driver</a>, we'll also require the following gems:</p><p>The gem for the driver itself:</p><pre><code>$ gem install mongo</code></pre><p>and the driver's other prerequisite, bson:</p><pre><code>$ gem install bson_ext</code></pre><p>This is basically a collection of extensions used to increase serialization speed.</p><p>That's it for our prerequisites!.</p><h2 id="tutorial">Tutorial</h2><p>To get started, let's get a local copy of the practical application working on our system.</p><h3 id="application-files">Application Files</h3><p>Clone <a href="http://github.com/addyosmani/backbone-fundamentals">this</a> repository and navigate to <code>/practicals/stacks/option3</code>. Now run the following lines at the terminal:</p><pre><code>ruby app.rb</code></pre><p>Finally, navigate to <code>http://localhost:4567/todo</code> to see the application running successfully.</p><p><strong>Note:</strong> The Haml layout files for Option 3 can be found in the /views folder.</p><p>The directory structure for our practical application is as follows:</p><pre><code>--public
----css
----img
----js
-----script.js
----test
--views
app.rb
</code></pre><p>The <code>public</code> directory contains the scripts and stylesheets for our application and uses HTML5 Boilerplate as a base. You can find the Models, Views and Collections for this section within <code>public/js/scripts.js</code> (however, this can of course be expanded into sub-directories for each component if desired).</p><p><code>scripts.js</code> contains the following Backbone component definitions:</p><pre><code>--Models
----Todo

--Collections
----TodoList

--Views
---TodoView
---AppView</code></pre><p><code>app.rb</code> is the small Sinatra application that powers our backend API.</p><p>Lastly, the <code>views</code> directory hosts the Haml source files for our application's index and templates, both of which are compiled to standard HTML markup at runtime.</p><p>These can be viewed along with other note-worthy snippets of code from the application below.</p><h3 id="backbone">Backbone</h3><h4 id="views">Views</h4><p>In our main application view (AppView), we want to load any previously stored Todo items in our Mongo database when the view initializes. This is done below with the line <code>Todos.fetch()</code> in the <code>initialize()</code> method where we also bind to the relevant events on the <code>Todos</code> collection for when items are added or changed.</p><pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="co">// Our overall **AppView** is the top-level piece of UI.</span>
<span class="kw">var</span> AppView = <span class="kw">Backbone.View</span>.<span class="fu">extend</span>({

    <span class="co">// Instead of generating a new element, bind to the existing skeleton of</span>
    <span class="co">// the App already present in the HTML.</span>
    <span class="dt">el</span>: $(<span class="st">&quot;#todoapp&quot;</span>),

    <span class="co">// Our template for the line of statistics at the bottom of the app.</span>
    <span class="dt">statsTemplate</span>: <span class="kw">_</span>.<span class="fu">template</span>($(<span class="ch">&#39;#stats-template&#39;</span>).<span class="fu">html</span>()),

    <span class="co">// Delegated events for creating new items, and clearing completed ones.</span>
    <span class="dt">events</span>: {
      <span class="st">&quot;keypress #new-todo&quot;</span>:  <span class="st">&quot;createOnEnter&quot;</span>,
      <span class="st">&quot;keyup #new-todo&quot;</span>:     <span class="st">&quot;showTooltip&quot;</span>,
      <span class="st">&quot;click .todo-clear a&quot;</span>: <span class="st">&quot;clearCompleted&quot;</span>
    },

    <span class="co">// At initialization</span>
    <span class="dt">initialize</span>: <span class="kw">function</span>() {
      <span class="kw">this</span>.<span class="fu">input</span>    = <span class="kw">this</span>.$(<span class="st">&quot;#new-todo&quot;</span>);

      <span class="kw">Todos</span>.<span class="fu">on</span>(<span class="ch">&#39;add&#39;</span>,   <span class="kw">this</span>.<span class="fu">addOne</span>, <span class="kw">this</span>);
      <span class="kw">Todos</span>.<span class="fu">on</span>(<span class="ch">&#39;reset&#39;</span>, <span class="kw">this</span>.<span class="fu">addAll</span>, <span class="kw">this</span>);
      <span class="kw">Todos</span>.<span class="fu">on</span>(<span class="ch">&#39;all&#39;</span>,   <span class="kw">this</span>.<span class="fu">render</span>, <span class="kw">this</span>);

      <span class="kw">Todos</span>.<span class="fu">fetch</span>();
    },

    <span class="co">// Re-rendering the App just means refreshing the statistics -- the rest</span>
    <span class="co">// of the app doesn&#39;t change.</span>
    <span class="dt">render</span>: <span class="kw">function</span>() {
      <span class="kw">this</span>.$(<span class="ch">&#39;#todo-stats&#39;</span>).<span class="fu">html</span>(<span class="kw">this</span>.<span class="fu">statsTemplate</span>({
        <span class="dt">total</span>:      <span class="kw">Todos</span>.<span class="fu">length</span>,
        <span class="dt">done</span>:   
 ….</code></pre><h3 id="collections">Collections</h3><p>In the TodoList collection below, we've set the <code>url</code> property to point to <code>/api/todos</code> to reference the collection's location on the server. When we attempt to access this from our Sinatra-backed API, it should return a list of all the Todo items that have been previously stored in Mongo.</p><p>For the sake of thoroughness, our API will also support returning the data for a specific Todo item via <code>/api/todos/itemID</code>. We'll take a look at this again when writing the Ruby code powering our backend.</p><pre class="sourceCode javascript"><code class="sourceCode javascript"> <span class="co">// Todo Collection</span>

  <span class="kw">var</span> TodoList = <span class="kw">Backbone.Collection</span>.<span class="fu">extend</span>({

    <span class="co">// Reference to this collection&#39;s model.</span>
    <span class="dt">model</span>: Todo,

    <span class="co">// Save all of the todo items under the `&quot;todos&quot;` namespace.</span>
    <span class="co">// localStorage: new Store(&quot;todos&quot;),</span>
    <span class="dt">url</span>: <span class="ch">&#39;/api/todos&#39;</span>,

    <span class="co">// Filter down the list of all todo items that are finished.</span>
    <span class="dt">done</span>: <span class="kw">function</span>() {
      <span class="kw">return</span> <span class="kw">this</span>.<span class="fu">filter</span>(<span class="kw">function</span>(todo){ <span class="kw">return</span> <span class="kw">todo</span>.<span class="fu">get</span>(<span class="ch">&#39;done&#39;</span>); });
    },

    <span class="co">// Filter down the list to only todo items that are still not finished.</span>
    <span class="dt">remaining</span>: <span class="kw">function</span>() {
      <span class="kw">return</span> <span class="kw">this</span>.<span class="fu">without</span>.<span class="fu">apply</span>(<span class="kw">this</span>, <span class="kw">this</span>.<span class="fu">done</span>());
    },

    <span class="co">// We keep the Todos in sequential order, despite being saved by unordered</span>
    <span class="co">// GUID in the database. This generates the next order number for new items.</span>
    <span class="dt">nextOrder</span>: <span class="kw">function</span>() {
      <span class="kw">if</span> (!<span class="kw">this</span>.<span class="fu">length</span>) <span class="kw">return</span> <span class="dv">1</span>;
      <span class="kw">return</span> <span class="kw">this</span>.<span class="fu">last</span>().<span class="fu">get</span>(<span class="ch">&#39;order&#39;</span>) + <span class="dv">1</span>;
    },

    <span class="co">// Todos are sorted by their original insertion order.</span>
    <span class="dt">comparator</span>: <span class="kw">function</span>(todo) {
      <span class="kw">return</span> <span class="kw">todo</span>.<span class="fu">get</span>(<span class="ch">&#39;order&#39;</span>);
    }

  });</code></pre><h3 id="model">Model</h3><p>The model for our Todo application remains largely unchanged from the versions previously covered in this book. It is however worth noting that calling the function <code>model.url()</code> within the below would return the relative URL where a specific Todo item could be located on the server.</p><pre class="sourceCode javascript"><code class="sourceCode javascript">
  <span class="co">// Our basic **Todo** model has `text`, `order`, and `done` attributes.</span>
  <span class="kw">var</span> Todo = <span class="kw">Backbone.Model</span>.<span class="fu">extend</span>({
    <span class="dt">idAttribute</span>: <span class="st">&quot;_id&quot;</span>,

    <span class="co">// Default attributes for a todo item.</span>
    <span class="dt">defaults</span>: <span class="kw">function</span>() {
      <span class="kw">return</span> {
        <span class="dt">done</span>:  <span class="kw">false</span>,
        <span class="dt">order</span>: <span class="kw">Todos</span>.<span class="fu">nextOrder</span>()
      };
    },

    <span class="co">// Toggle the `done` state of this todo item.</span>
    <span class="dt">toggle</span>: <span class="kw">function</span>() {
      <span class="kw">this</span>.<span class="fu">save</span>({<span class="dt">done</span>: !<span class="kw">this</span>.<span class="fu">get</span>(<span class="st">&quot;done&quot;</span>)});
    }
  });</code></pre><h3 id="rubysinatra">Ruby/Sinatra</h3><p>Now that we've defined our main models, views and collections let's get the CRUD operations required by our Backbone application supported in our Sinatra API.</p><p>We want to make sure that for any operations changing underlying data (create, update, delete) that our Mongo data store correctly reflects these.</p><h3 id="app.rb">app.rb</h3><p>For <code>app.rb</code>, we first define the dependencies required by our application. These include Sinatra, Ruby Gems, the MongoDB Ruby driver and the JSON gem.</p><pre class="sourceCode ruby"><code class="sourceCode ruby">require <span class="st">&#39;rubygems&#39;</span>
require <span class="st">&#39;sinatra&#39;</span>
require <span class="st">&#39;mongo&#39;</span>
require <span class="st">&#39;json&#39;</span></code></pre><p>Next, we create a new connection to Mongo, specifying any custom configuration desired. If running a multi-threaded application, setting the 'pool_size' allows us to specify a maximum pool size and 'timeout' a maximum timeout for waiting for old connections to be released to the pool.</p><pre class="sourceCode ruby"><code class="sourceCode ruby"><span class="dt">DB</span> = <span class="dt">Mongo</span>::<span class="dt">Connection</span>.new.db(<span class="st">&quot;mydb&quot;</span>, <span class="st">:pool_size</span> =&gt; <span class="dv">5</span>, <span class="st">:timeout</span> =&gt; <span class="dv">5</span>)</code></pre><p>Finally we define the routes to be supported by our API. Note that in the first two blocks - one for our application root (<code>/</code>) and the other for our todo items route <code>/todo</code> - we're using Haml for template rendering.</p><pre class="sourceCode ruby"><code class="sourceCode ruby"><span class="kw">class</span> <span class="dt">TodoApp</span> &lt; <span class="dt">Sinatra</span>::<span class="dt">Base</span>

    get <span class="st">&#39;/&#39;</span> <span class="kw">do</span>
      haml <span class="st">:index</span>, <span class="st">:attr_wrapper</span> =&gt; <span class="st">&#39;&quot;&#39;</span>, <span class="st">:locals</span> =&gt; {<span class="st">:title</span> =&gt; <span class="st">&#39;hello&#39;</span>}
    <span class="kw">end</span>

    get <span class="st">&#39;/todo&#39;</span> <span class="kw">do</span>
      haml <span class="st">:todo</span>, <span class="st">:attr_wrapper</span> =&gt; <span class="st">&#39;&quot;&#39;</span>, <span class="st">:locals</span> =&gt; {<span class="st">:title</span> =&gt; <span class="st">&#39;Our Sinatra Todo app&#39;</span>}
    <span class="kw">end</span></code></pre><p><code>haml :index</code> instructs Sinatra to use the <code>views/index.haml</code> for the application index, whilst `<code>attr_wrapper</code> is simply defining the values to be used for any local variables defined inside the template. This similarly applies Todo items with the template `views/todo.haml'.</p><p>The rest of our routes make use of the <code>params</code> hash and a number of useful helper methods included with the MongoDB Ruby driver. For more details on these, please read the comments I've made inline below:</p><pre class="sourceCode ruby"><code class="sourceCode ruby">get <span class="st">&#39;/api/:thing&#39;</span> <span class="kw">do</span>
  <span class="co"># query a collection :thing, convert the output to an array, map the _id </span>
  <span class="co"># to a string representation of the object&#39;s _id and finally output to JSON</span>
  <span class="dt">DB</span>.collection(params[<span class="st">:thing</span>]).find.to_a.map{|t| from_bson_id(t)}.to_json
<span class="kw">end</span>

get <span class="st">&#39;/api/:thing/:id&#39;</span> <span class="kw">do</span>
  <span class="co"># get the first document with the id :id in the collection :thing as a single document (rather </span>
  <span class="co"># than a Cursor, the standard output) using find_one(). Our bson utilities assist with</span>
  <span class="co"># ID conversion and the final output returned is also JSON</span>
  from_bson_id(<span class="dt">DB</span>.collection(params[<span class="st">:thing</span>]).find_one(to_bson_id(params[<span class="st">:id</span>]))).to_json
<span class="kw">end</span>

post <span class="st">&#39;/api/:thing&#39;</span> <span class="kw">do</span>
  <span class="co"># parse the post body of the content being posted, convert to a string, insert into</span>
  <span class="co"># the collection #thing and return the ObjectId as a string for reference</span>
  oid = <span class="dt">DB</span>.collection(params[<span class="st">:thing</span>]).insert(<span class="dt">JSON</span>.parse(request.body.read.to_s))
  <span class="st">&quot;{\&quot;_id\&quot;: \&quot;</span><span class="ot">#{</span>oid.to_s<span class="ot">}</span><span class="st">\&quot;}&quot;</span>
<span class="kw">end</span>

delete <span class="st">&#39;/api/:thing/:id&#39;</span> <span class="kw">do</span>
  <span class="co"># remove the item with id :id from the collection :thing, based on the bson</span>
  <span class="co"># representation of the object id</span>
  <span class="dt">DB</span>.collection(params[<span class="st">:thing</span>]).remove(<span class="st">&#39;_id&#39;</span> =&gt; to_bson_id(params[<span class="st">:id</span>]))
<span class="kw">end</span>

put <span class="st">&#39;/api/:thing/:id&#39;</span> <span class="kw">do</span>
  <span class="co"># collection.update() when used with $set (as covered earlier) allows us to set single values</span>
  <span class="co"># in this case, the put request body is converted to a string, rejecting keys with the name &#39;_id&#39; for security purposes</span>
  <span class="dt">DB</span>.collection(params[<span class="st">:thing</span>]).update({<span class="st">&#39;_id&#39;</span> =&gt; to_bson_id(params[<span class="st">:id</span>])}, {<span class="st">&#39;$set&#39;</span> =&gt; <span class="dt">JSON</span>.parse(request.body.read.to_s).reject{|k,v| k == <span class="st">&#39;_id&#39;</span>}})
<span class="kw">end</span>

<span class="co"># utilities for generating/converting MongoDB ObjectIds</span>
<span class="kw">def</span> to_bson_id(id) <span class="dt">BSON</span>::<span class="dt">ObjectId</span>.from_string(id) <span class="kw">end</span>
<span class="kw">def</span> from_bson_id(obj) obj.merge({<span class="st">&#39;_id&#39;</span> =&gt; obj[<span class="st">&#39;_id&#39;</span>].to_s}) <span class="kw">end</span>

<span class="kw">end</span></code></pre><p>That's it. The above is extremely lean for an entire API, but does allow us to read and write data to support the functionality required by our client-side application.</p><p>For more on what MongoDB and the MongoDB Ruby driver are capable of, please do feel free to read their documentation for more information.</p><p>If you're a developer wishing to take this example further, why not try to add some additional capabilities to the service:</p><ul><li>Validation: improved validation of data in the API. What more could be done to ensure data sanitization?</li><li>Search: search or filter down Todo items based on a set of keywords or within a certain date range</li><li>Pagination: only return the Nth number of Todo items or items from a start and end-point</li></ul><h3 id="hamltemplates">Haml/Templates</h3><p>Finally, we move on to the Haml files that define our application index (layout.haml) and the template for a specific Todo item (todo.haml). Both of these are largely self-explanatory, but it's useful to see the differences between the Jade approach we reviewed in the last chapter vs. using Haml for this implementation.</p><p>Note: In our Haml snippets below, the forward slash character is used to indicate a comment. When this character is placed at the beginning of a line, it wraps all of the text after it into a HTML comment. e.g</p><p><code>/ These are templates</code></p><p>compiles to:</p><p><code>&lt;!-- These are templates --&gt;</code></p><h3 id="index.haml">index.haml</h3><pre class="sourceCode html"><code class="sourceCode html">%head
  %meta{&#39;charset&#39; =&gt; &#39;utf-8&#39;}/
  %title=title
  %meta{&#39;name&#39; =&gt; &#39;description&#39;, &#39;content&#39; =&gt; &#39;&#39;}/
  %meta{&#39;name&#39; =&gt; &#39;author&#39;, &#39;content&#39; =&gt; &#39;&#39;}/
  %meta{&#39;name&#39; =&gt; &#39;viewport&#39;, &#39;content&#39; =&gt; &#39;width=device-width,initial-scale=1&#39;}/

  / CSS concatenated and minified via ant build script
  %link{&#39;rel&#39; =&gt; &#39;stylesheet&#39;, &#39;href&#39; =&gt; &#39;css/style.css&#39;}/
  / end CSS

  %script{&#39;src&#39; =&gt; &#39;js/libs/modernizr.min.js&#39;}
%body
  %div#container
    %header
    %div#main
      = yield
    %footer
  /! end of #container

  %script{&#39;src&#39; =&gt; &#39;http://ajax.googleapis.com/ajax/libs/jquery/1.7.1/jquery.min.js&#39;}

  / scripts concatenated and minified via ant build script
  %script{&#39;src&#39; =&gt; &#39;js/mylibs/underscore.js&#39;}
  %script{&#39;src&#39; =&gt; &#39;js/mylibs/backbone.js&#39;}
  %script{&#39;defer&#39; =&gt; true, &#39;src&#39; =&gt; &#39;js/plugins.js&#39;}
  %script{&#39;defer&#39; =&gt; true, &#39;src&#39; =&gt; &#39;js/script.js&#39;}
  / end scripts</code></pre><h3 id="todo.haml">todo.haml</h3><pre class="sourceCode html"><code class="sourceCode html">%div#todoapp
  %div.title
    %h1
      Todos
      %div.content
        %div#create-todo
          %input#new-todo{&quot;placeholder&quot; =&gt; &quot;What needs to be done?&quot;, &quot;type&quot; =&gt; &quot;text&quot;}/
          %span.ui-tooltip-top{&quot;style&quot; =&gt; &quot;display:none;&quot;} Press Enter to save this task
        %div#todos
          %ul#todo-list
        %div#todo-stats

/ Templates

%script#item-template{&quot;type&quot; =&gt; &quot;text/template&quot;}
  <span class="kw">&lt;div</span><span class="ot"> class=</span><span class="st">&quot;todo </span><span class="er">&lt;</span><span class="st">%= done ? &#39;done&#39; : &#39;&#39; %&gt;&quot;</span><span class="kw">&gt;</span>
  %div.display
    <span class="kw">&lt;input</span><span class="ot"> class=</span><span class="st">&quot;check&quot;</span><span class="ot"> type=</span><span class="st">&quot;checkbox&quot;</span> <span class="er">&lt;%</span><span class="ot">=</span> <span class="st">done</span> <span class="st">?</span> <span class="er">&#39;checked</span><span class="ot">=</span><span class="st">&quot;checked&quot;</span><span class="er">&#39;</span><span class="ot"> :</span> <span class="er">&#39;&#39;</span> <span class="er">%</span><span class="kw">&gt;</span> /&gt;
    %div.todo-text 
    %span#todo-destroy
  %div.edit
    %input.todo-input{&quot;type&quot; =&gt; &quot;text&quot;, &quot;value&quot; =&gt;&quot;&quot;}/
  <span class="kw">&lt;/div&gt;</span>

%script#stats-template{&quot;type&quot; =&gt; &quot;text/template&quot;}
  <span class="er">&lt;</span>% if (total) { %&gt;
  %span.todo-count
    %span.number <span class="er">&lt;</span>%= remaining %&gt;
    %span.word <span class="er">&lt;</span>%= remaining == 1 ? &#39;item&#39; : &#39;items&#39; %&gt;
    left.
  <span class="er">&lt;</span>% } %&gt;
  <span class="er">&lt;</span>% if (done) { %&gt;
  %span.todo-clear
    %a{&quot;href&quot; =&gt; &quot;#&quot;}
      Clear
      %span.number-done <span class="er">&lt;</span>%= done %&gt;
      completed
      %span.word-done <span class="er">&lt;</span>%= done == 1 ? &#39;item&#39; : &#39;items&#39; %&gt;
  <span class="er">&lt;</span>% } %&gt;</code></pre><h2 id="conclusions">Conclusions</h2><p>In this chapter, we looked at creating a Backbone application backed by an API powered by Ruby, Sinatra, Haml, MongoDB and the MongoDB driver. I personally found developing APIs with Sinatra a relatively painless experience and one which I felt was on-par with the effort required for the Node/Express implementation of the same application.</p><p>This section is by no means the most comprehensive guide on building complex apps using all of the items in this particular stack. I do however hope it was an introduction sufficient enough to help you decide on what stack to try out for your next project.</p><h2 id="advanced"># <a name="advanced">Advanced</a></h2><h2 id="modular-javascript"><a name="modularjs">Modular JavaScript</a></h2><p>When we say an application is modular, we generally mean it's composed of a set of highly decoupled, distinct pieces of functionality stored in modules. As you probably know, loose coupling facilitates easier maintainability of apps by removing dependencies where possible. When this is implemented efficiently, its quite easy to see how changes to one part of a system may affect another.</p><p>Unlike some more traditional programming languages however, the current iteration of JavaScript (ECMA-262) doesn't provide developers with the means to import such modules of code in a clean, organized manner. It's one of the concerns with specifications that haven't required great thought until more recent years where the need for more organized JavaScript applications became apparent.</p><p>Instead, developers at present are left to fall back on variations of the module or object literal patterns. With many of these, module scripts are strung together in the DOM with namespaces being described by a single global object where it's still possible to incur naming collisions in your architecture. There's also no clean way to handle dependency management without some manual effort or third party tools.</p><p>Whilst native solutions to these problems will be arriving in ES Harmony, the good news is that writing modular JavaScript has never been easier and you can start doing it today.</p><p>In this next part of the book, we're going to look at how to use AMD modules and RequireJS for cleanly wrapping units of code in your application into manageable modules.</p><h2 id="organizing-modules-with-requirejs-and-amd"><a name="organizingmodules">Organizing modules with RequireJS and AMD</a></h2><p>In case you haven't used it before, <a href="http://requirejs.org">RequireJS</a> is a popular script loader written by James Burke - a developer who has been quite instrumental in helping shape the AMD module format, which we'll discuss more shortly. Some of RequireJS's capabilities include helping to load multiple script files, helping define modules with or without dependencies and loading in non-script dependencies such as text files.</p><p>So, why use RequireJS with Backbone? Although Backbone is excellent when it comes to providing a sanitary structure to your applications, there are a few key areas where some additional help could be used:</p><ol style="list-style-type: decimal"><li>Backbone doesn't endorse a particular approach to modular-development. Although this means it's quite open-ended for developers to opt for classical patterns like the module-pattern or Object Literals for structuring their apps (which both work fine), it also means developers aren't sure of what works best when other concerns come into play, such as dependency management.</li></ol><p>RequireJS is compatible with the AMD (Asynchronous Module Definition) format, a format which was born from a desire to write something better than the 'write lots of script tags with implicit dependencies and manage them manually' approach to development. In addition to allowing you to clearly declare dependencies, AMD works well in the browser, supports string IDs for dependencies, declaring multiple modules in the same file and gives you easy-to-use tools to avoid polluting the global namespace.</p><ol start="2" style="list-style-type: decimal"><li>Let's discuss dependency management a little more as it can actually be quite challenging to get right if you're doing it by hand. When we write modules in JavaScript, we ideally want to be able to handle the reuse of code units intelligently and sometimes this will mean pulling in other modules at run-time whilst at other times you may want to do this dynamically to avoid a large pay-load when the user first hits your application.</li></ol><p>Think about the GMail web-client for a moment. When users initially load up the page on their first visit, Google can simply hide widgets such as the chat module until a user has indicated (by clicking 'expand') that they wish to use it. Through dynamic dependency loading, Google could load up the chat module only then, rather than forcing all users to load it when the page first initializes. This can improve performance and load times and can definitely prove useful when building larger applications.</p><p>I've previously written <a href="http://addyosmani.com/writing-modular-js">a detailed article</a> covering both AMD and other module formats and script loaders in case you'd like to explore this topic further. The takeaway is that although it's perfectly fine to develop applications without a script loader or clean module format in place, it can be of significant benefit to consider using these tools in your application development.</p><h3 id="writing-amd-modules-with-requirejs">Writing AMD modules with RequireJS</h3><p>As discussed above, the overall goal for the AMD format is to provide a solution for modular JavaScript that developers can use today. The two key concepts you need to be aware of when using it with a script-loader are a <code>define()</code> method for facilitating module definition and a <code>require()</code> method for handling dependency loading. <code>define()</code> is used to define named or unnamed modules based on the proposal using the following signature:</p><pre class="sourceCode javascript"><code class="sourceCode javascript">define(
    module_id <span class="co">/*optional*/</span>, 
    [dependencies] <span class="co">/*optional*/</span>, 
    definition <span class="kw">function</span> <span class="co">/*function for instantiating the module or object*/</span>
);</code></pre><p>As you can tell by the inline comments, the <code>module_id</code> is an optional argument which is typically only required when non-AMD concatenation tools are being used (there may be some other edge cases where it's useful too). When this argument is left out, we call the module 'anonymous'. When working with anonymous modules, the idea of a module's identity is DRY, making it trivial to avoid duplication of filenames and code.</p><p>Back to the define signature, the dependencies argument represents an array of dependencies which are required by the module you are defining and the third argument ('definition function') is a function that's executed to instantiate your module. A barebone module (compatible with RequireJS) could be defined using <code>define()</code> as follows:</p><pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="co">// A module ID has been omitted here to make the module anonymous</span>

define([<span class="ch">&#39;foo&#39;</span>, <span class="ch">&#39;bar&#39;</span>], 
    <span class="co">// module definition function</span>
    <span class="co">// dependencies (foo and bar) are mapped to function parameters</span>
    <span class="kw">function</span> ( foo, bar ) {
        <span class="co">// return a value that defines the module export</span>
        <span class="co">// (i.e the functionality we want to expose for consumption)</span>

        <span class="co">// create your module here</span>
        <span class="kw">var</span> myModule = {
            <span class="dt">doStuff</span>:<span class="kw">function</span>(){
                <span class="kw">console</span>.<span class="fu">log</span>(<span class="ch">&#39;Yay! Stuff&#39;</span>);
            }
        }

        <span class="kw">return</span> myModule;
});</code></pre><h4 id="alternate-syntax">Alternate syntax</h4><p>There is also a <a href="http://requirejs.org/docs/whyamd.html#sugar">sugared version</a> of <code>define()</code> available that allows you to declare your dependencies as local variables using <code>require()</code>. This will feel familiar to anyone who's used node, and can be easier to add or remove dependencies. Here is the previous snippet using the alternate syntax:</p><pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="co">// A module ID has been omitted here to make the module anonymous</span>

define(<span class="kw">function</span>(require){
        <span class="co">// module definition function</span>
    <span class="co">// dependencies (foo and bar) are defined as local vars</span>
    <span class="kw">var</span> foo = require(<span class="ch">&#39;foo&#39;</span>),
        bar = require(<span class="ch">&#39;bar&#39;</span>);

        <span class="co">// return a value that defines the module export</span>
        <span class="co">// (i.e the functionality we want to expose for consumption)</span>

        <span class="co">// create your module here</span>
        <span class="kw">var</span> myModule = {
            <span class="dt">doStuff</span>:<span class="kw">function</span>(){
                <span class="kw">console</span>.<span class="fu">log</span>(<span class="ch">&#39;Yay! Stuff&#39;</span>);
            }
        }

        <span class="kw">return</span> myModule;
});</code></pre><p>The <code>require()</code> method is typically used to load code in a top-level JavaScript file or within a module should you wish to dynamically fetch dependencies. An example of its usage is:</p><pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="co">// Consider &#39;foo&#39; and &#39;bar&#39; are two external modules</span>
<span class="co">// In this example, the &#39;exports&#39; from the two modules loaded are passed as</span>
<span class="co">// function arguments to the callback (foo and bar)</span>
<span class="co">// so that they can similarly be accessed</span>

require([<span class="ch">&#39;foo&#39;</span>, <span class="ch">&#39;bar&#39;</span>], <span class="kw">function</span> ( foo, bar ) {
        <span class="co">// rest of your code here</span>
        <span class="kw">foo</span>.<span class="fu">doSomething</span>();
});</code></pre><p><strong>Wrapping modules, views and other components with AMD</strong></p><p>Now that we've taken a look at how to define AMD modules, let's review how to go about wrapping components like views and collections so that they can also be easily loaded as dependencies for any parts of your application that require them. At it's simplest, a Backbone model may just require Backbone and Underscore.js. These are considered it's dependencies and so, to write an AMD model module, we would simply do this:</p><pre class="sourceCode javascript"><code class="sourceCode javascript">define([<span class="ch">&#39;underscore&#39;</span>, <span class="ch">&#39;backbone&#39;</span>], <span class="kw">function</span>(_, Backbone) {
  <span class="kw">var</span> myModel = <span class="kw">Backbone.Model</span>.<span class="fu">extend</span>({

    <span class="co">// Default attributes </span>
    <span class="dt">defaults</span>: {
      <span class="dt">content</span>: <span class="st">&quot;hello world&quot;</span>,
    },

    <span class="co">// A dummy initialization method</span>
    <span class="dt">initialize</span>: <span class="kw">function</span>() {
    },

    <span class="dt">clear</span>: <span class="kw">function</span>() {
      <span class="kw">this</span>.<span class="fu">destroy</span>();
      <span class="kw">this</span>.<span class="fu">view</span>.<span class="fu">remove</span>();
    }

  });
  <span class="kw">return</span> myModel;
});</code></pre><p>Note how we alias Underscore.js's instance to <code>_</code> and Backbone to just <code>Backbone</code>, making it very trivial to convert non-AMD code over to using this module format. For a view which might require other dependencies such as jQuery, this can similarly be done as follows:</p><pre class="sourceCode javascript"><code class="sourceCode javascript">define([
  <span class="ch">&#39;jquery&#39;</span>,
  <span class="ch">&#39;underscore&#39;</span>, 
  <span class="ch">&#39;backbone&#39;</span>,
  <span class="ch">&#39;collections/mycollection&#39;</span>,
  <span class="ch">&#39;views/myview&#39;</span>
  ], <span class="kw">function</span>($, _, Backbone, myCollection, myView){

  <span class="kw">var</span> AppView = <span class="kw">Backbone.View</span>.<span class="fu">extend</span>({
  ...</code></pre><p>Aliasing to the dollar-sign (<code>$</code>), once again makes it very easy to encapsulate any part of an application you wish using AMD.</p><h2 id="keeping-your-templates-external-using-requirejs-and-the-text-plugin"><a name="externaltemplates">Keeping Your Templates External Using RequireJS And The Text Plugin</a></h2><p>Moving your [Underscore/Mustache/Handlebars] templates to external files is actually quite straight-forward. As this application makes use of RequireJS, I'll discuss how to implement external templates using this specific script loader.</p><p>RequireJS has a special plugin called text.js which is used to load in text file dependencies. To use the text plugin, simply follow these simple steps:</p><ol style="list-style-type: decimal"><li><p>Download the plugin from http://requirejs.org/docs/download.html#text and place it in either the same directory as your application's main JS file or a suitable sub-directory.</p></li><li><p>Next, include the text.js plugin in your initial RequireJS configuration options. In the code snippet below, we assume that RequireJS is being included in our page prior to this code snippet being executed. Any of the other scripts being loaded are just there for the sake of example.</p></li></ol><pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="kw">require</span>.<span class="fu">config</span>( {
    <span class="dt">paths</span>: {
        <span class="ch">&#39;backbone&#39;</span>:         <span class="ch">&#39;libs/AMDbackbone-0.5.3&#39;</span>,
        <span class="ch">&#39;underscore&#39;</span>:       <span class="ch">&#39;libs/underscore-1.2.2&#39;</span>,
        <span class="ch">&#39;text&#39;</span>:             <span class="ch">&#39;libs/require/text&#39;</span>,
        <span class="ch">&#39;jquery&#39;</span>:           <span class="ch">&#39;libs/jQuery-1.7.1&#39;</span>,
        <span class="ch">&#39;json2&#39;</span>:            <span class="ch">&#39;libs/json2&#39;</span>,
        <span class="ch">&#39;datepicker&#39;</span>:       <span class="ch">&#39;libs/jQuery.ui.datepicker&#39;</span>,
        <span class="ch">&#39;datepickermobile&#39;</span>: <span class="ch">&#39;libs/jquery.ui.datepicker.mobile&#39;</span>,
        <span class="ch">&#39;jquerymobile&#39;</span>:     <span class="ch">&#39;libs/jquery.mobile-1.0&#39;</span>
    },
    <span class="dt">baseUrl</span>: <span class="ch">&#39;app&#39;</span>
} );</code></pre><ol start="3" style="list-style-type: decimal"><li>When the <code>text!</code> prefix is used for a dependency, RequireJS will automatically load the text plugin and treat the dependency as a text resource. A typical example of this in action may look like..</li></ol><pre class="sourceCode javascript"><code class="sourceCode javascript">require([<span class="ch">&#39;js/app&#39;</span>, <span class="ch">&#39;text!templates/mainView.html&#39;</span>],
    <span class="kw">function</span>(app, mainView){
        <span class="co">// the contents of the mainView file will be</span>
        <span class="co">// loaded into mainView for usage.</span>
    }
);</code></pre><ol start="4" style="list-style-type: decimal"><li>Finally we can use the text resource that's been loaded for templating purposes. You're probably used to storing your HTML templates inline using a script with a specific identifier.</li></ol><p>With Underscore.js's micro-templating (and jQuery) this would typically be:</p><p>HTML:</p><pre><code>&lt;script type=&quot;text/template&quot; id=&quot;mainViewTemplate&quot;&gt;
    &lt;% _.each( person, function( person_item ){ %&gt;
        &lt;li&gt;&lt;%= person_item.get(&quot;name&quot;) %&gt;&lt;/li&gt;  
    &lt;% }); %&gt;
&lt;/script&gt;</code></pre><p>JS:</p><pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="kw">var</span> compiled_template = <span class="kw">_</span>.<span class="fu">template</span>( $(<span class="ch">&#39;#mainViewTemplate&#39;</span>).<span class="fu">html</span>() );</code></pre><p>With RequireJS and the text plugin however, it's as simple as saving your template into an external text file (say, <code>mainView.html</code>) and doing the following:</p><pre class="sourceCode javascript"><code class="sourceCode javascript">require([<span class="ch">&#39;js/app&#39;</span>, <span class="ch">&#39;text!templates/mainView.html&#39;</span>],
    <span class="kw">function</span>(app, mainView){

        <span class="kw">var</span> compiled_template = <span class="kw">_</span>.<span class="fu">template</span>( mainView );
    }
);</code></pre><p>That's it!. You can then go applying your template to a view in Backbone doing something like:</p><pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="kw">collection.someview.el</span>.<span class="fu">html</span>( compiled_template( { <span class="dt">results</span>: <span class="kw">collection</span>.<span class="fu">models</span> } ) );</code></pre><p>All templating solutions will have their own custom methods for handling template compilation, but if you understand the above, substituting Underscore's micro-templating for any other solution should be fairly trivial.</p><p><strong>Note:</strong> You may also be interested in looking at <a href="https://github.com/ZeeAgency/requirejs-tpl">Require.js tpl</a>. It's an AMD-compatible version of the Underscore templating system that also includes support for optimization (pre-compiled templates) which can lead to better performance and no evals. I have yet to use it myself, but it comes as a recommended resource.</p><h2 id="optimizing-backbone-apps-for-production-with-the-requirejs-optimizer"><a name="optimizingrequirejs">Optimizing Backbone apps for production with the RequireJS Optimizer</a></h2><p>As experienced developers may know, an essential final step when writing both small and large JavaScript web applications is the build process. The majority of non-trivial apps are likely to consist of more than one or two scripts and so optimizing, minimizing and concatenating your scripts prior to pushing them to production will require your users to download a reduced number (if not just one) script file.</p><p>Note: If you haven't looked at build processes before and this is your first time hearing about them, you might find <a href="http://addyosmani.com/blog/client-side-build-process/">my post and screencast on this topic</a> useful.</p><p>With some other structural JavaScript frameworks, my recommendation would normally be to implicitly use YUI Compressor or Google's closure compiler tools, but we have a slightly more elegant method available, when it comes to Backbone if you're using RequireJS. RequireJS has a command line optimization tool called r.js which has a number of capabilities, including:</p><ul><li>Concatenating specific scripts and minifying them using external tools such as UglifyJS (which is used by default) or Google's Closure Compiler for optimal browser delivery, whilst preserving the ability to dynamically load modules</li><li>Optimizing CSS and stylesheets by inlining CSS files imported using @import, stripping out comments etc.</li><li>The ability to run AMD projects in both Node and Rhino (more on this later)</li></ul><p>You'll notice that I mentioned the word 'specific' in the first bullet point. The RequireJS optimizer only concatenates module scripts that have been specified in arrays of string literals passed to top-level (i.e non-local) require and define calls. As clarified by the <a href="http://requirejs.org/docs/optimization.html">optimizer docs</a> this means that Backbone modules defined like this:</p><pre class="sourceCode javascript"><code class="sourceCode javascript">define([<span class="ch">&#39;jquery&#39;</span>,<span class="ch">&#39;backbone&#39;</span>,<span class="ch">&#39;underscore&#39;</span>, <span class="ch">&#39;collections/sample&#39;</span>,<span class="ch">&#39;views/test&#39;</span>], 
    <span class="kw">function</span>($,Backbone, _, Sample, Test){
        <span class="co">//...</span>
    });</code></pre><p>will combine fine, however inline dependencies such as:</p><pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="kw">var</span> models = someCondition ? [<span class="ch">&#39;models/ab&#39;</span>,<span class="ch">&#39;models/ac&#39;</span>] : [<span class="ch">&#39;models/ba&#39;</span>,<span class="ch">&#39;models/bc&#39;</span>];</code></pre><p>will be ignored. This is by design as it ensures that dynamic dependency/module loading can still take place even after optimization.</p><p>Although the RequireJS optimizer works fine in both Node and Java environments, it's strongly recommended to run it under Node as it executes significantly faster there. In my experience, it's a piece of cake to get setup with either environment, so go for whichever you feel most comfortable with.</p><p>To get started with r.js, grab it from the <a href="http://requirejs.org/docs/download.html#rjs">RequireJS download page</a> or <a href="http://requirejs.org/docs/optimization.html#download">through NPM</a>. Now, the RequireJS optimizer works absolutely fine for single script and CSS files, but for most cases you'll want to actually optimize an entire Backbone project. You <em>could</em> do this completely from the command-line, but a cleaner option is using build profiles.</p><p>Below is an example of a build file taken from the modular jQuery Mobile app referenced later in this book. A <strong>build profile</strong> (commonly named <code>app.build.js</code>) informs RequireJS to copy all of the content of <code>appDir</code> to a directory defined by <code>dir</code> (in this case <code>../release</code>). This will apply all of the necessary optimizations inside the release folder. The <code>baseUrl</code> is used to resolve the paths for your modules. It should ideally be relative to <code>appDir</code>.</p><p>Near the bottom of this sample file, you'll see an array called <code>modules</code>. This is where you specify the module names you wish to have optimized. In this case we're optimizing the main application called 'app', which maps to <code>appDir/app.js</code>. If we had set the <code>baseUrl</code> to 'scripts', it would be mapped to <code>appDir/scripts/app.js</code>.</p><pre class="sourceCode javascript"><code class="sourceCode javascript">({
    <span class="dt">appDir</span>: <span class="st">&quot;./&quot;</span>,
    <span class="dt">baseUrl</span>: <span class="st">&quot;./&quot;</span>,
    <span class="dt">dir</span>: <span class="st">&quot;../release&quot;</span>,
    <span class="dt">paths</span>: {
       <span class="ch">&#39;backbone&#39;</span>:          <span class="ch">&#39;libs/AMDbackbone-0.5.3&#39;</span>,
        <span class="ch">&#39;underscore&#39;</span>:       <span class="ch">&#39;libs/underscore-1.2.2&#39;</span>,
        <span class="ch">&#39;jquery&#39;</span>:           <span class="ch">&#39;libs/jQuery-1.7.1&#39;</span>,
        <span class="ch">&#39;json2&#39;</span>:            <span class="ch">&#39;libs/json2&#39;</span>,
        <span class="ch">&#39;datepicker&#39;</span>:       <span class="ch">&#39;libs/jQuery.ui.datepicker&#39;</span>,
        <span class="ch">&#39;datepickermobile&#39;</span>: <span class="ch">&#39;libs/jquery.ui.datepicker.mobile&#39;</span>,
        <span class="ch">&#39;jquerymobile&#39;</span>:     <span class="ch">&#39;libs/jquery.mobile-1.0&#39;</span>
    },
    <span class="dt">optimize</span>: <span class="st">&quot;uglify&quot;</span>,
    <span class="dt">modules</span>: [
        {
            <span class="dt">name</span>: <span class="st">&quot;app&quot;</span>,
            <span class="dt">exclude</span>: [
                <span class="co">// If you prefer not to include certain libs exclude them here</span>
            ]
        }
    ]
})</code></pre><p>The way the build system in r.js works is that it traverses app.js (whatever modules you've passed) and resolved dependencies, concatenating them into the final <code>release</code>(dir) folder. CSS is treated the same way.</p><p>The build profile is usually placed inside the 'scripts' or 'js' directory of your project. As per the docs, this file can however exist anywhere you wish, but you'll need to edit the contents of your build profile accordingly.</p><p>Finally, to run the build, execute the following command once inside your <code>appDir</code> or <code>appDir/scripts</code> directory:</p><pre class="sourceCode javascript"><code class="sourceCode javascript">node ../../<span class="kw">r</span>.<span class="fu">js</span> -o <span class="kw">app.build</span>.<span class="fu">js</span></code></pre><p>That's it. As long as you have UglifyJS/Closure tools setup correctly, r.js should be able to easily optimize your entire Backbone project in just a few key-strokes. If you would like to learn more about build profiles, James Burke has a <a href="https://github.com/jrburke/r.js/blob/master/build/example.build.js">heavily commented sample file</a> with all the possible options available.</p><h2 id="practical-building-a-modular-backbone-app-with-amd-requirejs"><a name="practicalrequirejs">Practical: Building a modular Backbone app with AMD &amp; RequireJS</a></h2><p>In this chapter, we'll look at our first practical Backbone &amp; RequireJS project - how to build a modular Todo application. The application will allow us to add new todos, edit new todos and clear todo items that have been marked as completed. For a more advanced practical, see the section on mobile Backbone development.</p><p>The complete code for the application can can be found in the <code>practicals/modular-todo-app</code> folder of this repo (thanks to Thomas Davis and Jérôme Gravel-Niquet). Alternatively grab a copy of my side-project <a href="https://github.com/addyosmani/todomvc">TodoMVC</a> which contains the sources to both AMD and non-AMD versions.</p><p><strong>Note:</strong> Thomas may be covering a practical on this exercise in more detail on <a href="http://backbonetutorials.com">backbonetutorials.com</a> at some point soon, but for this section I'll be covering what I consider the core concepts.</p><h3 id="overview">Overview</h3><p>Writing a 'modular' Backbone application can be a straight-forward process. There are however, some key conceptual differences to be aware of if opting to use AMD as your module format of choice:</p><ul><li>As AMD isn't a standard native to JavaScript or the browser, it's necessary to use a script loader (such as RequireJS or curl.js) in order to support defining components and modules using this module format. As we've already reviewed, there are a number of advantages to using the AMD as well as RequireJS to assist here.</li><li>Models, views, controllers and routers need to be encapsulated <em>using</em> the AMD-format. This allows each component of our Backbone application to cleanly manage dependencies (e.g collections required by a view) in the same way that AMD allows non-Backbone modules to.</li><li>Non-Backbone components/modules (such as utilities or application helpers) can also be encapsulated using AMD. I encourage you to try developing these modules in such a way that they can both be used and tested independent of your Backbone code as this will increase their ability to be re-used elsewhere.</li></ul><p>Now that we've reviewed the basics, let's take a look at developing our application. For reference, the structure of our app is as follows:</p><pre><code>index.html
...js/
    main.js
    .../models
            todo.js
    .../views
            app.js
            todos.js
    .../collections
            todos.js
    .../templates
            stats.html
            todos.html
    ../libs
        .../backbone
        .../jquery
        .../underscore
        .../require
                require.js
                text.js
...css/</code></pre><h3 id="markup">Markup</h3><p>The markup for the application is relatively simple and consists of three primary parts: an input section for entering new todo items (<code>create-todo</code>), a list section to display existing items (which can also be edited in-place) (<code>todo-list</code>) and finally a section summarizing how many items are left to be completed (<code>todo-stats</code>).</p><pre><code>&lt;div id=&quot;todoapp&quot;&gt;

      &lt;div class=&quot;content&quot;&gt;

        &lt;div id=&quot;create-todo&quot;&gt;
          &lt;input id=&quot;new-todo&quot; placeholder=&quot;What needs to be done?&quot; type=&quot;text&quot; /&gt;
          &lt;span class=&quot;ui-tooltip-top&quot;&gt;Press Enter to save this task&lt;/span&gt;
        &lt;/div&gt;

        &lt;div id=&quot;todos&quot;&gt;
          &lt;ul id=&quot;todo-list&quot;&gt;&lt;/ul&gt;
        &lt;/div&gt;

        &lt;div id=&quot;todo-stats&quot;&gt;&lt;/div&gt;

      &lt;/div&gt;

&lt;/div&gt;</code></pre><p>The rest of the tutorial will now focus on the JavaScript side of the practical.</p><h3 id="configuration-options">Configuration options</h3><p>If you've read the earlier chapter on AMD, you may have noticed that explicitly needing to define each dependency a Backbone module (view, collection or other module) may require with it can get a little tedious. This can however be improved.</p><p>In order to simplify referencing common paths the modules in our application may use, we use a RequireJS <a href="http://requirejs.org/docs/api.html#config">configuration object</a>, which is typically defined as a top-level script file. Configuration objects have a number of useful capabilities, the most useful being mode name-mapping. Name-maps are basically a key:value pair, where the key defines the alias you wish to use for a path and the value represents the true location of the path.</p><p>In the code-sample below, you can see some typical examples of common name-maps which include: <code>backbone</code>, <code>underscore</code>, <code>jquery</code> and depending on your choice, the RequireJS <code>text</code> plugin, which assists with loading text assets like templates.</p><p><strong>main.js</strong></p><pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="kw">require</span>.<span class="fu">config</span>({
  <span class="dt">baseUrl</span>:<span class="ch">&#39;../&#39;</span>,
  <span class="dt">paths</span>: {
    <span class="dt">jquery</span>: <span class="ch">&#39;libs/jquery/jquery-min&#39;</span>,
    <span class="dt">underscore</span>: <span class="ch">&#39;libs/underscore/underscore-min&#39;</span>,
    <span class="dt">backbone</span>: <span class="ch">&#39;libs/backbone/backbone-optamd3-min&#39;</span>,
    <span class="dt">text</span>: <span class="ch">&#39;libs/require/text&#39;</span>
  }
});

require([<span class="ch">&#39;views/app&#39;</span>], <span class="kw">function</span>(AppView){
  <span class="kw">var</span> app_view = <span class="kw">new</span> AppView;
});</code></pre><p>The <code>require()</code> at the end of our main.js file is simply there so we can load and instantiation the primary view for our application (<code>views/app.js</code>). You'll commonly see both this and the configuration object included the most top-level script file for a project.</p><p>In addition to offering name-mapping, the configuration object can be used to define additional properties such as <code>waitSeconds</code> - the number of seconds to wait before script loading times out and <code>locale</code>, should you wish to load up i18n bundles for custom languages. The <code>baseUrl</code> is simply the path to use for module lookups.</p><p>For more information on configuration objects, please feel free to check out the excellent guide to them in the <a href="http://requirejs.org/docs/api.html#config">RequireJS docs</a>.</p><h3 id="modularizing-our-models-views-and-collections">Modularizing our models, views and collections</h3><p>Before we dive into AMD-wrapped versions of our Backbone components, let's review a sample of a non-AMD view. The following view listens for changes to its model (a Todo item) and re-renders if a user edits the value of the item.</p><pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="kw">var</span> TodoView = <span class="kw">Backbone.View</span>.<span class="fu">extend</span>({

    <span class="co">//... is a list tag.</span>
    <span class="dt">tagName</span>:  <span class="st">&quot;li&quot;</span>,

    <span class="co">// Cache the template function for a single item.</span>
    <span class="dt">template</span>: <span class="kw">_</span>.<span class="fu">template</span>($(<span class="ch">&#39;#item-template&#39;</span>).<span class="fu">html</span>()),

    <span class="co">// The DOM events specific to an item.</span>
    <span class="dt">events</span>: {
      <span class="st">&quot;click .check&quot;</span>              : <span class="st">&quot;toggleDone&quot;</span>,
      <span class="st">&quot;dblclick div.todo-content&quot;</span> : <span class="st">&quot;edit&quot;</span>,
      <span class="st">&quot;click span.todo-destroy&quot;</span>   : <span class="st">&quot;clear&quot;</span>,
      <span class="st">&quot;keypress .todo-input&quot;</span>      : <span class="st">&quot;updateOnEnter&quot;</span>
    },

    <span class="co">// The TodoView listens for changes to its model, re-rendering. Since there&#39;s</span>
    <span class="co">// a one-to-one correspondence between a **Todo** and a **TodoView** in this</span>
    <span class="co">// app, we set a direct reference on the model for convenience.</span>
    <span class="dt">initialize</span>: <span class="kw">function</span>() {      
      <span class="kw">this</span>.<span class="fu">model</span>.<span class="fu">bind</span>(<span class="ch">&#39;change&#39;</span>, <span class="kw">this</span>.<span class="fu">render</span>, <span class="kw">this</span>);
      <span class="kw">this</span>.<span class="fu">model</span>.<span class="fu">view</span> = <span class="kw">this</span>;
    },
    ...</code></pre><p>Note how for templating the common practice of referencing a script by an ID (or other selector) and obtaining its value is used. This of course requires that the template being accessed is implicitly defined in our markup. The following is the 'embedded' version of our template being referenced above:</p><pre><code>&lt;script type=&quot;text/template&quot; id=&quot;item-template&quot;&gt;
      &lt;div class=&quot;todo &lt;%= done ? &#39;done&#39; : &#39;&#39; %&gt;&quot;&gt;
        &lt;div class=&quot;display&quot;&gt;
          &lt;input class=&quot;check&quot; type=&quot;checkbox&quot; &lt;%= done ? &#39;checked=&quot;checked&quot;&#39; : &#39;&#39; %&gt; /&gt;
          &lt;div class=&quot;todo-content&quot;&gt;&lt;/div&gt;
          &lt;span class=&quot;todo-destroy&quot;&gt;&lt;/span&gt;
        &lt;/div&gt;
        &lt;div class=&quot;edit&quot;&gt;
          &lt;input class=&quot;todo-input&quot; type=&quot;text&quot; value=&quot;&quot; /&gt;
        &lt;/div&gt;
      &lt;/div&gt;
&lt;/script&gt;</code></pre><p>Whilst there is nothing wrong with the template itself, once we begin to develop larger applications requiring multiple templates, including them all in our markup on page-load can quickly become both unmanageable and come with performance costs. We'll look at solving this problem in a minute.</p><p>Let's now take a look at the AMD-version of our view. As discussed earlier, the 'module' is wrapped using AMD's <code>define()</code> which allows us to specify the dependencies our view requires. Using the mapped paths to 'jquery' etc. simplifies referencing common dependencies and instances of dependencies are themselves mapped to local variables that we can access (e.g 'jquery' is mapped to <code>$</code>).</p><p><strong>views/todos.js</strong></p><pre class="sourceCode javascript"><code class="sourceCode javascript">define([
  <span class="ch">&#39;jquery&#39;</span>, 
  <span class="ch">&#39;underscore&#39;</span>, 
  <span class="ch">&#39;backbone&#39;</span>,
  <span class="ch">&#39;text!templates/todos.html&#39;</span>
  ], <span class="kw">function</span>($, _, Backbone, todosTemplate){
  <span class="kw">var</span> TodoView = <span class="kw">Backbone.View</span>.<span class="fu">extend</span>({

    <span class="co">//... is a list tag.</span>
    <span class="dt">tagName</span>:  <span class="st">&quot;li&quot;</span>,

    <span class="co">// Cache the template function for a single item.</span>
    <span class="dt">template</span>: <span class="kw">_</span>.<span class="fu">template</span>(todosTemplate),

    <span class="co">// The DOM events specific to an item.</span>
    <span class="dt">events</span>: {
      <span class="st">&quot;click .check&quot;</span>              : <span class="st">&quot;toggleDone&quot;</span>,
      <span class="st">&quot;dblclick div.todo-content&quot;</span> : <span class="st">&quot;edit&quot;</span>,
      <span class="st">&quot;click span.todo-destroy&quot;</span>   : <span class="st">&quot;clear&quot;</span>,
      <span class="st">&quot;keypress .todo-input&quot;</span>      : <span class="st">&quot;updateOnEnter&quot;</span>
    },

    <span class="co">// The TodoView listens for changes to its model, re-rendering. Since there&#39;s</span>
    <span class="co">// a one-to-one correspondence between a **Todo** and a **TodoView** in this</span>
    <span class="co">// app, we set a direct reference on the model for convenience.</span>
    <span class="dt">initialize</span>: <span class="kw">function</span>() {      
      <span class="kw">this</span>.<span class="fu">model</span>.<span class="fu">bind</span>(<span class="ch">&#39;change&#39;</span>, <span class="kw">this</span>.<span class="fu">render</span>, <span class="kw">this</span>);
      <span class="kw">this</span>.<span class="fu">model</span>.<span class="fu">view</span> = <span class="kw">this</span>;
    },

    <span class="co">// Re-render the contents of the todo item.</span>
    <span class="dt">render</span>: <span class="kw">function</span>() {
      $(<span class="kw">this</span>.<span class="fu">el</span>).<span class="fu">html</span>(<span class="kw">this</span>.<span class="fu">template</span>(<span class="kw">this</span>.<span class="fu">model</span>.<span class="fu">toJSON</span>()));
      <span class="kw">this</span>.<span class="fu">setContent</span>();
      <span class="kw">return</span> <span class="kw">this</span>;
    },

    <span class="co">// Use `jQuery.text` to set the contents of the todo item.</span>
    <span class="dt">setContent</span>: <span class="kw">function</span>() {
      <span class="kw">var</span> content = <span class="kw">this</span>.<span class="fu">model</span>.<span class="fu">get</span>(<span class="ch">&#39;content&#39;</span>);
      <span class="kw">this</span>.$(<span class="ch">&#39;.todo-content&#39;</span>).<span class="fu">text</span>(content);
      <span class="kw">this</span>.<span class="fu">input</span> = <span class="kw">this</span>.$(<span class="ch">&#39;.todo-input&#39;</span>);
      <span class="kw">this</span>.<span class="fu">input</span>.<span class="fu">bind</span>(<span class="ch">&#39;blur&#39;</span>, <span class="kw">this</span>.<span class="fu">close</span>);
      <span class="kw">this</span>.<span class="fu">input</span>.<span class="fu">val</span>(content);
    },
    ...</code></pre><p>From a maintenance perspective, there's nothing logically different in this version of our view, except for how we approach templating.</p><p>Using the RequireJS text plugin (the dependency marked <code>text</code>), we can actually store all of the contents for the template we looked at earlier in an external file (todos.html).</p><p><strong>templates/todos.html</strong></p><pre class="sourceCode html"><code class="sourceCode html"><span class="kw">&lt;div</span><span class="ot"> class=</span><span class="st">&quot;todo </span><span class="er">&lt;</span><span class="st">%= done ? &#39;done&#39; : &#39;&#39; %&gt;&quot;</span><span class="kw">&gt;</span>
    <span class="kw">&lt;div</span><span class="ot"> class=</span><span class="st">&quot;display&quot;</span><span class="kw">&gt;</span>
      <span class="kw">&lt;input</span><span class="ot"> class=</span><span class="st">&quot;check&quot;</span><span class="ot"> type=</span><span class="st">&quot;checkbox&quot;</span> <span class="er">&lt;%</span><span class="ot">=</span> <span class="st">done</span> <span class="st">?</span> <span class="er">&#39;checked</span><span class="ot">=</span><span class="st">&quot;checked&quot;</span><span class="er">&#39;</span><span class="ot"> :</span> <span class="er">&#39;&#39;</span> <span class="er">%</span><span class="kw">&gt;</span> /&gt;
      <span class="kw">&lt;div</span><span class="ot"> class=</span><span class="st">&quot;todo-content&quot;</span><span class="kw">&gt;&lt;/div&gt;</span>
      <span class="kw">&lt;span</span><span class="ot"> class=</span><span class="st">&quot;todo-destroy&quot;</span><span class="kw">&gt;&lt;/span&gt;</span>
    <span class="kw">&lt;/div&gt;</span>
    <span class="kw">&lt;div</span><span class="ot"> class=</span><span class="st">&quot;edit&quot;</span><span class="kw">&gt;</span>
      <span class="kw">&lt;input</span><span class="ot"> class=</span><span class="st">&quot;todo-input&quot;</span><span class="ot"> type=</span><span class="st">&quot;text&quot;</span><span class="ot"> value=</span><span class="st">&quot;&quot;</span> <span class="kw">/&gt;</span>
    <span class="kw">&lt;/div&gt;</span>
<span class="kw">&lt;/div&gt;</span></code></pre><p>There's no longer a need to be concerned with IDs for the template as we can map it's contents to a local variable (in this case <code>todosTemplate</code>). We then simply pass this to the Underscore.js templating function <code>_.template()</code> the same way we normally would have the value of our template script.</p><p>Next, let's look at how to define models as dependencies which can be pulled into collections. Here's an AMD-compatible model module, which has two default values: a <code>content</code> attribute for the content of a Todo item and a boolean <code>done</code> state, allowing us to trigger whether the item has been completed or not.</p><p><strong>models/todo.js</strong></p><pre class="sourceCode javascript"><code class="sourceCode javascript">define([<span class="ch">&#39;underscore&#39;</span>, <span class="ch">&#39;backbone&#39;</span>], <span class="kw">function</span>(_, Backbone) {
  <span class="kw">var</span> TodoModel = <span class="kw">Backbone.Model</span>.<span class="fu">extend</span>({

    <span class="co">// Default attributes for the todo.</span>
    <span class="dt">defaults</span>: {
      <span class="co">// Ensure that each todo created has `content`.</span>
      <span class="dt">content</span>: <span class="st">&quot;empty todo...&quot;</span>,
      <span class="dt">done</span>: <span class="kw">false</span>
    },

    <span class="dt">initialize</span>: <span class="kw">function</span>() {
    },

    <span class="co">// Toggle the `done` state of this todo item.</span>
    <span class="dt">toggle</span>: <span class="kw">function</span>() {
      <span class="kw">this</span>.<span class="fu">save</span>({<span class="dt">done</span>: !<span class="kw">this</span>.<span class="fu">get</span>(<span class="st">&quot;done&quot;</span>)});
    },

    <span class="co">// Remove this Todo from *localStorage* and delete its view.</span>
    <span class="dt">clear</span>: <span class="kw">function</span>() {
      <span class="kw">this</span>.<span class="fu">destroy</span>();
      <span class="kw">this</span>.<span class="fu">view</span>.<span class="fu">remove</span>();
    }

  });
  <span class="kw">return</span> TodoModel;
});</code></pre><p>As per other types of dependencies, we can easily map our model module to a local variable (in this case <code>Todo</code>) so it can be referenced as the model to use for our <code>TodosCollection</code>. This collection also supports a simple <code>done()</code> filter for narrowing down Todo items that have been completed and a <code>remaining()</code> filter for those that are still outstanding.</p><p><strong>collections/todos.js</strong></p><pre class="sourceCode javascript"><code class="sourceCode javascript">define([
  <span class="ch">&#39;underscore&#39;</span>, 
  <span class="ch">&#39;backbone&#39;</span>, 
  <span class="ch">&#39;libs/backbone/localstorage&#39;</span>, 
  <span class="ch">&#39;models/todo&#39;</span>
  ], <span class="kw">function</span>(_, Backbone, Store, Todo){

    <span class="kw">var</span> TodosCollection = <span class="kw">Backbone.Collection</span>.<span class="fu">extend</span>({

    <span class="co">// Reference to this collection&#39;s model.</span>
    <span class="dt">model</span>: Todo,

    <span class="co">// Save all of the todo items under the `&quot;todos&quot;` namespace.</span>
    <span class="dt">localStorage</span>: <span class="kw">new</span> Store(<span class="st">&quot;todos&quot;</span>),

    <span class="co">// Filter down the list of all todo items that are finished.</span>
    <span class="dt">done</span>: <span class="kw">function</span>() {
      <span class="kw">return</span> <span class="kw">this</span>.<span class="fu">filter</span>(<span class="kw">function</span>(todo){ <span class="kw">return</span> <span class="kw">todo</span>.<span class="fu">get</span>(<span class="ch">&#39;done&#39;</span>); });
    },

    <span class="co">// Filter down the list to only todo items that are still not finished.</span>
    <span class="dt">remaining</span>: <span class="kw">function</span>() {
      <span class="kw">return</span> <span class="kw">this</span>.<span class="fu">without</span>.<span class="fu">apply</span>(<span class="kw">this</span>, <span class="kw">this</span>.<span class="fu">done</span>());
    },
    ...</code></pre><p>In addition to allowing users to add new Todo items from views (which we then insert as models in a collection), we ideally also want to be able to display how many items have been completed and how many are remaining. We've already defined filters that can provide us this information in the above collection, so let's use them in our main application view.</p><p><strong>views/app.js</strong></p><pre class="sourceCode javascript"><code class="sourceCode javascript">define([
  <span class="ch">&#39;jquery&#39;</span>,
  <span class="ch">&#39;underscore&#39;</span>, 
  <span class="ch">&#39;backbone&#39;</span>,
  <span class="ch">&#39;collections/todos&#39;</span>,
  <span class="ch">&#39;views/todos&#39;</span>,
  <span class="ch">&#39;text!templates/stats.html&#39;</span>
  ], <span class="kw">function</span>($, _, Backbone, Todos, TodoView, statsTemplate){

  <span class="kw">var</span> AppView = <span class="kw">Backbone.View</span>.<span class="fu">extend</span>({

    <span class="co">// Instead of generating a new element, bind to the existing skeleton of</span>
    <span class="co">// the App already present in the HTML.</span>
    <span class="dt">el</span>: $(<span class="st">&quot;#todoapp&quot;</span>),

    <span class="co">// Our template for the line of statistics at the bottom of the app.</span>
    <span class="dt">statsTemplate</span>: <span class="kw">_</span>.<span class="fu">template</span>(statsTemplate),

    <span class="co">// ...events, initialize() etc. can be seen in the complete file</span>

    <span class="co">// Re-rendering the App just means refreshing the statistics -- the rest</span>
    <span class="co">// of the app doesn&#39;t change.</span>
    <span class="dt">render</span>: <span class="kw">function</span>() {
      <span class="kw">var</span> done = <span class="kw">Todos</span>.<span class="fu">done</span>().<span class="fu">length</span>;
      <span class="kw">this</span>.$(<span class="ch">&#39;#todo-stats&#39;</span>).<span class="fu">html</span>(<span class="kw">this</span>.<span class="fu">statsTemplate</span>({
        <span class="dt">total</span>:      <span class="kw">Todos</span>.<span class="fu">length</span>,
        <span class="dt">done</span>:       <span class="kw">Todos</span>.<span class="fu">done</span>().<span class="fu">length</span>,
        <span class="dt">remaining</span>:  <span class="kw">Todos</span>.<span class="fu">remaining</span>().<span class="fu">length</span>
      }));
    },
    ...</code></pre><p>Above, we map the second template for this project, <code>templates/stats.html</code> to <code>statsTemplate</code> which is used for rendering the overall <code>done</code> and <code>remaining</code> states. This works by simply passing our template the length of our overall Todos collection (<code>Todos.length</code> - the number of Todo items created so far) and similarly the length (counts) for items that have been completed (<code>Todos.done().length</code>) or are remaining (<code>Todos.remaining().length</code>).</p><p>The contents of our <code>statsTemplate</code> can be seen below. It's nothing too complicated, but does use ternary conditions to evaluate whether we should state there's &quot;1 item&quot; or &quot;2 item<i>s</i>&quot; in a particular state.</p><pre><code>&lt;% if (total) { %&gt;
        &lt;span class=&quot;todo-count&quot;&gt;
          &lt;span class=&quot;number&quot;&gt;&lt;%= remaining %&gt;&lt;/span&gt;
          &lt;span class=&quot;word&quot;&gt;&lt;%= remaining == 1 ? &#39;item&#39; : &#39;items&#39; %&gt;&lt;/span&gt; left.
        &lt;/span&gt;
      &lt;% } %&gt;
      &lt;% if (done) { %&gt;
        &lt;span class=&quot;todo-clear&quot;&gt;
          &lt;a href=&quot;#&quot;&gt;
            Clear &lt;span class=&quot;number-done&quot;&gt;&lt;%= done %&gt;&lt;/span&gt;
            completed &lt;span class=&quot;word-done&quot;&gt;&lt;%= done == 1 ? &#39;item&#39; : &#39;items&#39; %&gt;&lt;/span&gt;
          &lt;/a&gt;
        &lt;/span&gt;
      &lt;% } %&gt;</code></pre><p>The rest of the source for the Todo app mainly consists of code for handling user and application events, but that rounds up most of the core concepts for this practical.</p><p>To see how everything ties together, feel free to grab the source by cloning this repo or browse it <a href="https://github.com/addyosmani/backbone-fundamentals/tree/master/practicals/modular-todo-app">online</a> to learn more. I hope you find it helpful!.</p><p><strong>Note:</strong> While this first practical doesn't use a build profile as outlined in the chapter on using the RequireJS optimizer, we will be using one in the section on building mobile Backbone applications.</p><h2 id="decoupling-backbone-with-the-mediator-and-facade-patterns"><a name="decouplingbackbone">Decoupling Backbone with the Mediator and Facade patterns</a></h2><p>In this section we'll discuss applying some of the concepts I cover in my article on <a href="http://addyosmani.com/largescalejavascript">Large-scale JavaScript Application development</a> to Backbone.</p><h3 id="summary">Summary</h3><p>At a high-level, one architecture that works for such applications is something which is:</p><ul><li><strong>Highly decoupled</strong>: encouraging modules to only publish and subscribe to events of interest rather than directly communicating with each other. This helps us to build applications who's units of code aren't highly tied (coupled) together and can thus be reused more easily.</li><li><strong>Supports module-level security</strong>: whereby modules are only able to execute behavior they've been permitted to. Application security is an area which is often overlooked in JavaScript applications, but can be quite easily implemented in a flexible manner.</li><li><strong>Supports failover</strong>: allowing an application continuing to function even if particular modules fail. The typical example I give of this is the GMail chat widget. Imagine being able to build applications in a way that if one widget on the page fails (e.g chat), the rest of your application (mail) can continue to function without being affected.</li></ul><p>This is an architecture which has been implemented by a number of different companies in the past, including Yahoo! (for their modularized homepage - which Nicholas Zakas has <a href="http://www.youtube.com/watch?v=vXjVFPosQHw">spoken</a> about) and AOL for some of our upcoming projects.</p><p>The three design patterns that make this architecture possible are the:</p><ul><li><strong>Module pattern</strong>: used for encapsulating unique blocks of code, where functions and variables can be kept either public or private. ('private' in the simulation of privacy sense, as of course don't have true privacy in JavaScript)</li><li><strong>Mediator pattern</strong>: used when the communication between modules may be complex, but is still well defined. If it appears a system may have too many relationships between modules in your code, it may be time to have a central point of control, which is where the pattern fits in.</li><li><strong>Facade pattern</strong>: used for providing a convenient higher-level interface to a larger body of code, hiding its true underlying complexity</li></ul><p>Their specific roles in this architecture can be found below.</p><ul><li><strong>Modules</strong>: There are almost two concepts of what defines a module. As AMD is being used as a module wrapper, technically each model, view and collection can be considered a module. We then have the concept of modules being distinct blocks of code outside of just MVC/MV*. For the latter, these types of 'modules' are primarily concerned with broadcasting and subscribing to events of interest rather than directly communicating with each other.They are made possible through the Mediator pattern.</li><li><strong>Mediator</strong>: The mediator has a varying role depending on just how you wish to implement it. In my article, I mention using it as a module manager with the ability to start and stop modules at will, however when it comes to Backbone, I feel that simplifying it down to the role of a central 'controller' that provides pub/sub capabilities should suffice. One can of course go all out in terms of building a module system that supports module starting, stopping, pausing etc, however the scope of this is outside of this chapter.</li><li><strong>Facade</strong>: This acts as a secure middle-layer that both abstracts an application core (Mediator) and relays messages from the modules back to the Mediator so they don't touch it directly. The Facade also performs the duty of application security guard; it checks event notifications from modules against a configuration (permissions.js, which we will look at later) to ensure requests from modules are only processed if they are permitted to execute the behavior passed.</li></ul><p>For ease of reference, I sometimes refer to these three patterns grouped together as Aura (a word that means subtle, luminous light).</p><h3 id="practical">Practical</h3><p>For the practical section of this chapter, we'll be extending the well-known Backbone Todo application using the three patterns mentioned above. The complete code for this section can be found here: https://github.com/addyosmani/backbone-aura and should ideally be run on at minimum, a local HTTP server.</p><p>The application is broken down into AMD modules that cover everything from Backbone models through to application-level modules. The views publish events of interest to the rest of the application and modules can then subscribe to these event notifications.</p><p>All subscriptions from modules go through a facade (or sandbox). What this does is check against the subscriber name and the 'channel/notification' it's attempting to subscribe to. If a channel <em>doesn't</em> have permissions to be subscribed to (something established through permissions.js), the subscription isn't permitted.</p><p><strong>Mediator</strong></p><p>Found in <code>aura/mediator.js</code></p><p>Below is a very simple AMD-wrapped implementation of the mediator pattern, based on prior work by Ryan Florence. It accepts as it's input an object, to which it attaches <code>publish()</code> and <code>subscribe()</code> methods. In a larger application, the mediator can contain additional utilities, such as handlers for initializing, starting and stopping modules, but for demonstration purposes, these two methods should work fine for our needs.</p><pre class="sourceCode javascript"><code class="sourceCode javascript">define([], <span class="kw">function</span>(obj){

  <span class="kw">var</span> channels = {};
  <span class="kw">if</span> (!obj) obj = {};

  <span class="kw">obj</span>.<span class="fu">subscribe</span> = <span class="kw">function</span> (channel, subscription) {
    <span class="kw">if</span> (!channels[channel]) channels[channel] = [];
    channels[channel].<span class="fu">push</span>(subscription);
  };

  <span class="kw">obj</span>.<span class="fu">publish</span> = <span class="kw">function</span> (channel) {
    <span class="kw">if</span> (!channels[channel]) <span class="kw">return</span>;
    <span class="kw">var</span> args = [].<span class="fu">slice</span>.<span class="fu">call</span>(arguments, <span class="dv">1</span>);
    <span class="kw">for</span> (<span class="kw">var</span> i = <span class="dv">0</span>, l = channels[channel].<span class="fu">length</span>; i &lt; l; i++) {
      channels[channel][i].<span class="fu">apply</span>(<span class="kw">this</span>, args);
    }
  };

  <span class="kw">return</span> obj;

});</code></pre><p><strong>Facade</strong></p><p>Found in <code>aura/facade.js</code></p><p>Next, we have an implementation of the facade pattern. Now the classical facade pattern applied to JavaScript would probably look a little like this:</p><pre class="sourceCode javascript"><code class="sourceCode javascript">
<span class="kw">var</span> module = (<span class="kw">function</span>() {
    <span class="kw">var</span> _private = {
        <span class="dt">i</span>:<span class="dv">5</span>,
        <span class="dt">get </span>: <span class="kw">function</span>() {
            <span class="kw">console</span>.<span class="fu">log</span>(<span class="ch">&#39;current value:&#39;</span> + <span class="kw">this</span>.<span class="fu">i</span>);
        },
        <span class="dt">set </span>: <span class="kw">function</span>( val ) {
            <span class="kw">this</span>.<span class="fu">i</span> = val;
        },
        <span class="dt">run </span>: <span class="kw">function</span>() {
            <span class="kw">console</span>.<span class="fu">log</span>(<span class="ch">&#39;running&#39;</span>);
        },
        <span class="dt">jump</span>: <span class="kw">function</span>(){
            <span class="kw">console</span>.<span class="fu">log</span>(<span class="ch">&#39;jumping&#39;</span>);
        }
    };
    <span class="kw">return</span> {
        <span class="dt">facade </span>: <span class="kw">function</span>( args ) {
            <span class="kw">_private</span>.<span class="fu">set</span>(<span class="kw">args</span>.<span class="fu">val</span>);
            <span class="kw">_private</span>.<span class="fu">get</span>();
            <span class="kw">if</span> ( <span class="kw">args</span>.<span class="fu">run</span> ) {
                <span class="kw">_private</span>.<span class="fu">run</span>();
            }
        }
    }
}());

<span class="kw">module</span>.<span class="fu">facade</span>({<span class="dt">run</span>: <span class="kw">true</span>, <span class="dt">val</span>:<span class="dv">10</span>});
<span class="co">//outputs current value: 10, running</span></code></pre><p>It's effectively a variation of the module pattern, where instead of simply returning an interface of supported methods, your API can completely hide the true implementation powering it, returning something simpler. This allows the logic being performed in the background to be as complex as necessary, whilst all the end-user experiences is a simplified API they pass options to (note how in our case, a single method abstraction is exposed). This is a beautiful way of providing APIs that can be easily consumed.</p><p>That said, to keep things simple, our implementation of an AMD-compatible facade will act a little more like a proxy. Modules will communicate directly through the facade to access the mediator's <code>publish()</code> and <code>subscribe()</code> methods, however, they won't as such touch the mediator directly.This enables the facade to provide application-level validation of any subscriptions and publications made.</p><p>It also allows us to implement a simple, but flexible, permissions checker (as seen below) which will validate subscriptions made against a permissions configuration to see whether it's permitted or not.</p><pre class="sourceCode javascript"><code class="sourceCode javascript">define([ <span class="st">&quot;../aura/mediator&quot;</span> , <span class="st">&quot;../aura/permissions&quot;</span> ], <span class="kw">function</span> (mediator, permissions) {

    <span class="kw">var</span> facade = facade || {};

    <span class="kw">facade</span>.<span class="fu">subscribe</span> = <span class="kw">function</span>(subscriber, channel, callback){

        <span class="co">// Note: Handling permissions/security is optional here</span>
        <span class="co">// The permissions check can be removed </span>
        <span class="co">// to just use the mediator directly.</span>

        <span class="kw">if</span>(<span class="kw">permissions</span>.<span class="fu">validate</span>(subscriber, channel)){
            <span class="kw">mediator</span>.<span class="fu">subscribe</span>( channel, callback );
        }
    }

    <span class="kw">facade</span>.<span class="fu">publish</span> = <span class="kw">function</span>(channel){
        <span class="kw">mediator</span>.<span class="fu">publish</span>( channel );
    }
    <span class="kw">return</span> facade;

});</code></pre><p><strong>Permissions</strong></p><p>Found in <code>aura/permissions.js</code></p><p>In our simple permissions configuration, we support checking against subscription requests to establish whether they are allowed to clear. This enforces a flexible security layer for the application.</p><p>To visually see how this works, consider changing say, permissions -&gt; renderDone -&gt; todoCounter to be false. This will completely disable the application from from rendering or displaying the counts component for Todo items left (because they aren't allowed to subscribe to that event notification). The rest of the Todo app can still however be used without issue.</p><p>It's a very dumbed down example of the potential for application security, but imagine how powerful this might be in a large app with a significant number of visual widgets.</p><pre class="sourceCode javascript"><code class="sourceCode javascript">define([], <span class="kw">function</span> () {

    <span class="co">// Permissions</span>

    <span class="co">// A permissions structure can support checking</span>
    <span class="co">// against subscriptions prior to allowing them </span>
    <span class="co">// to clear. This enforces a flexible security </span>
    <span class="co">// layer for your application.</span>

    <span class="kw">var</span> permissions = {

        <span class="dt">newContentAvailable</span>: {
            <span class="dt">contentUpdater</span>:<span class="kw">true</span>
        },

        <span class="dt">endContentEditing</span>:{
            <span class="dt">todoSaver</span>:<span class="kw">true</span>
        },

        <span class="dt">beginContentEditing</span>:{
            <span class="dt">editFocus</span>:<span class="kw">true</span>
        },

        <span class="dt">addingNewTodo</span>:{
            <span class="dt">todoTooltip</span>:<span class="kw">true</span>
        },

        <span class="dt">clearContent</span>:{
            <span class="dt">garbageCollector</span>:<span class="kw">true</span>
        },

        <span class="dt">renderDone</span>:{
            <span class="dt">todoCounter</span>:<span class="kw">true</span> <span class="co">//switch to false to see what happens :)</span>
        },

        <span class="dt">destroyContent</span>:{
            <span class="dt">todoRemover</span>:<span class="kw">true</span>
        },

        <span class="dt">createWhenEntered</span>:{
            <span class="dt">keyboardManager</span>:<span class="kw">true</span>
        }

    };

    <span class="kw">permissions</span>.<span class="fu">validate</span> = <span class="kw">function</span>(subscriber, channel){
        <span class="kw">var</span> test = permissions[channel][subscriber];
        <span class="kw">return</span> test===undefined? <span class="dt">false</span>: test;
    };

    <span class="kw">return</span> permissions;

});</code></pre><p><strong>Subscribers</strong></p><p>Found in <code>subscribers.js</code></p><p>Subscriber 'modules' communicate through the facade back to the mediator and perform actions when a notification event of a particular name is published.</p><p>For example, when a user enters in a new piece of text for a Todo item and hits 'enter' the application publishes a notification saying two things: a) a new Todo item is available and b) the text content of the new item is X. It's then left up to the rest of the application to do with this information whatever it wishes.</p><p>In order to update your Backbone application to primarily use pub/sub, a lot of the work you may end up doing will be moving logic coupled inside of specific views to modules outside of it which are reactionary.</p><p>Take the <code>todoSaver</code> for example - it's responsibility is saving new Todo items to models once the a <code>notificationName</code> called 'newContentAvailable' has fired. If you take a look at the permissions structure in the last code sample, you'll notice that 'newContentAvailable' is present there. If I wanted to prevent subscribers from being able to subscribe to this notification, I simply set it to a boolean value of <code>false</code>.</p><p>Again, this is a massive oversimplification of how advanced your permissions structures could get, but it's certainly one way of controlling what parts of your application can or can't be accessed by specific modules at any time.</p><pre class="sourceCode javascript"><code class="sourceCode javascript">define([<span class="st">&quot;jquery&quot;</span>, <span class="st">&quot;underscore&quot;</span>, <span class="st">&quot;aura/facade&quot;</span>], 
<span class="kw">function</span> ($, _, facade) {

    <span class="co">// Subscription &#39;modules&#39; for our views. These take the </span>
    <span class="co">// the form facade.subscribe( subscriberName, notificationName , callBack )</span>

    <span class="co">// Update view with latest todo content</span>
    <span class="co">// Subscribes to: newContentAvailable</span>

    <span class="kw">facade</span>.<span class="fu">subscribe</span>(<span class="ch">&#39;contentUpdater&#39;</span>, <span class="ch">&#39;newContentAvailable&#39;</span>, <span class="kw">function</span> (context) {
        <span class="kw">var</span> content = <span class="kw">context.model</span>.<span class="fu">get</span>(<span class="ch">&#39;content&#39;</span>);
        <span class="kw">context</span>.$(<span class="ch">&#39;.todo-content&#39;</span>).<span class="fu">text</span>(content);
        <span class="kw">context</span>.<span class="fu">input</span> = <span class="kw">context</span>.$(<span class="ch">&#39;.todo-input&#39;</span>);
        <span class="kw">context.input</span>.<span class="fu">bind</span>(<span class="ch">&#39;blur&#39;</span>, <span class="kw">context</span>.<span class="fu">close</span>);
        <span class="kw">context.input</span>.<span class="fu">val</span>(content);
    });


    <span class="co">// Save models when a user has finishes editing</span>
    <span class="co">// Subscribes to: endContentEditing</span>
    <span class="kw">facade</span>.<span class="fu">subscribe</span>(<span class="ch">&#39;todoSaver&#39;</span>,<span class="ch">&#39;endContentEditing&#39;</span>, <span class="kw">function</span> (context) {
        <span class="kw">try</span> {
            <span class="kw">context.model</span>.<span class="fu">save</span>({
                <span class="dt">content</span>: <span class="kw">context.input</span>.<span class="fu">val</span>()
            });
            $(<span class="kw">context</span>.<span class="fu">el</span>).<span class="fu">removeClass</span>(<span class="st">&quot;editing&quot;</span>);
        } <span class="kw">catch</span> (e) {
            <span class="co">//console.log(e);</span>
        }
    });


    <span class="co">// Delete a todo when the user no longer needs it</span>
    <span class="co">// Subscribes to: destroyContent</span>
    <span class="kw">facade</span>.<span class="fu">subscribe</span>(<span class="ch">&#39;todoRemover&#39;</span>,<span class="ch">&#39;destroyContent&#39;</span>, <span class="kw">function</span> (context) {
        <span class="kw">try</span> {
            <span class="kw">context.model</span>.<span class="fu">clear</span>();
        } <span class="kw">catch</span> (e) {
            <span class="co">//console.log(e);</span>
        }
    });


    <span class="co">// When a user is adding a new entry, display a tooltip</span>
    <span class="co">// Subscribes to: addingNewTodo</span>
    <span class="kw">facade</span>.<span class="fu">subscribe</span>(<span class="ch">&#39;todoTooltip&#39;</span>,<span class="ch">&#39;addingNewTodo&#39;</span>, <span class="kw">function</span> (context, todo) {
        <span class="kw">var</span> tooltip = <span class="kw">context</span>.$(<span class="st">&quot;.ui-tooltip-top&quot;</span>);
        <span class="kw">var</span> val = <span class="kw">context.input</span>.<span class="fu">val</span>();
        <span class="kw">tooltip</span>.<span class="fu">fadeOut</span>();
        <span class="kw">if</span> (<span class="kw">context</span>.<span class="fu">tooltipTimeout</span>) clearTimeout(<span class="kw">context</span>.<span class="fu">tooltipTimeout</span>);
        <span class="kw">if</span> (val == <span class="ch">&#39;&#39;</span> || val == <span class="kw">context.input</span>.<span class="fu">attr</span>(<span class="ch">&#39;placeholder&#39;</span>)) <span class="kw">return</span>;
        <span class="kw">var</span> show = <span class="kw">function</span> () {
                <span class="kw">tooltip</span>.<span class="fu">show</span>().<span class="fu">fadeIn</span>();
            };
        <span class="kw">context</span>.<span class="fu">tooltipTimeout</span> = <span class="kw">_</span>.<span class="fu">delay</span>(show, <span class="dv">1000</span>);
    });


    <span class="co">// Update editing UI on switching mode to editing content</span>
    <span class="co">// Subscribes to: beginContentEditing</span>
    <span class="kw">facade</span>.<span class="fu">subscribe</span>(<span class="ch">&#39;editFocus&#39;</span>,<span class="ch">&#39;beginContentEditing&#39;</span>, <span class="kw">function</span> (context) {
        $(<span class="kw">context</span>.<span class="fu">el</span>).<span class="fu">addClass</span>(<span class="st">&quot;editing&quot;</span>);
        <span class="kw">context.input</span>.<span class="fu">focus</span>();
    });


    <span class="co">// Create a new todo entry </span>
    <span class="co">// Subscribes to: createWhenEntered</span>
    <span class="kw">facade</span>.<span class="fu">subscribe</span>(<span class="ch">&#39;keyboardManager&#39;</span>,<span class="ch">&#39;createWhenEntered&#39;</span>, <span class="kw">function</span> (context, e, todos) {
        <span class="kw">if</span> (<span class="kw">e</span>.<span class="fu">keyCode</span> != <span class="dv">13</span>) <span class="kw">return</span>;
        <span class="kw">todos</span>.<span class="fu">create</span>(<span class="kw">context</span>.<span class="fu">newAttributes</span>());
        <span class="kw">context.input</span>.<span class="fu">val</span>(<span class="ch">&#39;&#39;</span>);
    });



    <span class="co">// A Todo and remaining entry counter</span>
    <span class="co">// Subscribes to: renderDone</span>
    <span class="kw">facade</span>.<span class="fu">subscribe</span>(<span class="ch">&#39;todoCounter&#39;</span>,<span class="ch">&#39;renderDone&#39;</span>, <span class="kw">function</span> (context, Todos) {
        <span class="kw">var</span> done = <span class="kw">Todos</span>.<span class="fu">done</span>().<span class="fu">length</span>;
        <span class="kw">context</span>.$(<span class="ch">&#39;#todo-stats&#39;</span>).<span class="fu">html</span>(<span class="kw">context</span>.<span class="fu">statsTemplate</span>({
            <span class="dt">total</span>: <span class="kw">Todos</span>.<span class="fu">length</span>,
            <span class="dt">done</span>: <span class="kw">Todos</span>.<span class="fu">done</span>().<span class="fu">length</span>,
            <span class="dt">remaining</span>: <span class="kw">Todos</span>.<span class="fu">remaining</span>().<span class="fu">length</span>
        }));
    });


    <span class="co">// Clear all completed todos when clearContent is dispatched</span>
    <span class="co">// Subscribes to: clearContent</span>
    <span class="kw">facade</span>.<span class="fu">subscribe</span>(<span class="ch">&#39;garbageCollector&#39;</span>,<span class="ch">&#39;clearContent&#39;</span>, <span class="kw">function</span> (Todos) {
        <span class="kw">_</span>.<span class="fu">each</span>(<span class="kw">Todos</span>.<span class="fu">done</span>(), <span class="kw">function</span> (todo) {
            <span class="kw">todo</span>.<span class="fu">clear</span>();
        });
    });


});</code></pre><p>That's it for this section. If you've been intrigued by some of the concepts covered, I encourage you to consider taking a look at my <a href="http://addyosmani.com/blog/large-scale-javascript-application-architecture/">slides</a> on Large-scale JS from the jQuery Summit or my longer post on the topic <a href="http://addyosmani.com/largescalejavascript">here</a> for more information.</p><h2 id="paginating-backbone.js-requests-collections"><a name="pagination">Paginating Backbone.js Requests &amp; Collections</a></h2><p>Pagination is a ubiquitous problem we often find ourselves needing to solve on the web. Perhaps most predominantly when working with back-end APIs and JavaScript-heavy clients which consume them.</p><p>On this topic, we're going to go through a set of **pagination components ** I wrote for Backbone.js, which should hopefully come in useful if you're working on applications which need to tackle this problem. They're part of an extension called <a href="http://github.com/addyosmani/backbone.paginator">Backbone.Paginator</a>.</p><p>When working with a structural framework like Backbone.js, the three types of pagination we are most likely to run into are:</p><p>**Requests to a service layer (API) **- e.g query for results containing the term 'Brendan' - if 5,000 results are available only display 20 results per page (leaving us with 250 possible result pages that can be navigated to).</p><p>This problem actually has quite a great deal more to it, such as maintaining persistence of other URL parameters (e.g sort, query, order) which can change based on a user's search configuration in a UI. One also had to think of a clean way of hooking views up to this pagination so you can easily navigate between pages (e.g First, Last, Next, Previous, 1,2,3), manage the number of results displayed per page and so on.</p><p><strong>Further client-side pagination of data returned -</strong> e.g we've been returned a JSON esponse containing 100 results. Rather than displaying all 100 to the user, we only display 20 of these results within a navigatable UI in the browser.</p><p>Similar to the request problem, client-pagination has its own challenges like navigation once again (Next, Previous, 1,2,3), sorting, order, switching the number of results to display per page and so on.</p><p><strong>Infinite results</strong> - with services such as Facebook, the concept of numeric pagination is instead replaced with a 'Load More' or 'View More' button. Triggering this normally fetches the next 'page' of N results but rather than replacing the previous set of results loaded entirely, we simply append to them instead.</p><p>A request pager which simply appends results in a view rather than replacing on each new fetch is effectively an 'infinite' pager.</p><p><strong>Let's now take a look at exactly what we're getting out of the box:</strong></p><p><em><a href="http://addyosmani.github.com/backbone.paginator/">Backbone.Paginator</a> is a set of opinionated components for paginating collections of data using Backbone.js. It aims to provide both solutions for assisting with pagination of requests to a server (e.g an API) as well as pagination of single-loads of data, where we may wish to further paginate a collection of N results into M pages within a view.</em></p><h2 id="paginators-pieces">Paginator's pieces</h2><p>Backbone.Paginator supports two main pagination components:</p><ul><li><strong>Backbone.Paginator.requestPager</strong>: For pagination of requests between a client and a server-side API</li><li><strong>Backbone.Paginator.clientPager</strong>: For pagination of data returned from a server which you would like to further paginate within the UI (e.g 60 results are returned, paginate into 3 pages of 20)</li></ul><h2 id="downloads-and-source-code">Downloads And Source Code</h2><p>You can either download the raw source code for the project, fork the repository or use one of these links:</p><ul><li><p>Production: <a href="https://raw.github.com/addyosmani/backbone.baginator/master/dist/backbone.paginator.min.js">production</a></p></li><li><p>Development: <a href="https://raw.github.com/addyosmani/backbone.baginator/master/dist/backbone.paginator.js">development version</a></p></li><li><p>Examples + Source : <a href="https://github.com/addyosmani/backbone.paginator/zipball/v0.153">zipball</a></p></li><li><p><a href="">Repository</a>http://github.com/addyosmani/backbone.paginator)</p></li></ul><h2 id="live-examples">Live Examples</h2><p>Live previews of both pagination components using the Netflix API can be found below. Download the tarball or fork the repository to experiment with these examples further.</p><p>Demo 1: <a href="http://addyosmani.github.com/backbone.paginator/examples/netflix-request-paging/index.html">Backbone.Paginator.requestPager()</a></p><img alt="" class="aligncenter size-large wp-image-4578" height="451" src="img/requestPager.png" style="margin-left:-17px;"  width="600" /><p>Demo 2: <a href="http://addyosmani.github.com/backbone.paginator/examples/netflix-client-paging/index.html">Backbone.Paginator.clientPager()</a></p><img alt="" class="aligncenter size-full wp-image-4579" height="462" src="img/clientPager.png"  width="600" /><p>Demo 3: <a href="http://addyosmani.github.com/backbone.paginator/examples/netflix-infinite-paging/index.html">Infinite Pagination (Backbone.Paginator.requestPager())</a></p><img alt="" class="aligncenter size-large wp-image-4580" height="451" src="img/infinitepager.png"  width="600" /><h2 id="paginator.requestpager">Paginator.requestPager</h2><p>In this section we're going to walkthrough actually using the requestPager.</p><h4 id="create-a-new-paginated-collection">1. Create a new Paginated collection</h4><p>First, we define a new Paginated collection using <code>Backbone.Paginator.requestPager()</code> as follows:</p><pre class="javascript" name="code">var PaginatedCollection = Backbone.Paginator.requestPager.extend({
</pre>
<h4 id="set-the-model-and-base-url-for-the-collection-as-normal">2: Set the model and base URL for the collection as normal</h4><p>Within our collection, we then (as normal) specify the model to be used with this collection followed by the URL (or base URL) for the service providing our data (e.g the Netflix API).</p><pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="dt">model</span>: model,
        <span class="dt">url</span>: <span class="ch">&#39;http://odata.netflix.com/v2/Catalog/Titles?&amp;&#39;</span>,</code></pre><h4 id="map-the-attributes-supported-by-your-api-url">3. Map the attributes supported by your API (URL)</h4><p>Next, we're going to map the request (URL) parameters supported by your API or backend data service back to attributes that are internally used by Backbone.Paginator.</p><p>For example: the NetFlix API refers to it's parameter for stating how many results to skip ahead by as <code>$skip</code> and it's number of items to return per page as <code>$top</code> (amongst others). We determine these by looking at a sample URL pointing at the service:</p><pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="dt">http</span>:<span class="co">//odata.netflix.com/v2/Catalog/Titles?&amp;callback=callback&amp;$top=30&amp;$skip=30&amp;orderBy=ReleaseYear&amp;$inlinecount=allpages&amp;$format=json&amp;$callback=callback&amp;$filter=substringof%28%27the%27,%20Name%29%20eq%20true&amp;_=1332702202090</span></code></pre><p>We then simply map these parameters to the relevant Paginator equivalents shown on the left hand side of the next snippets to get everything working:</p><pre class="sourceCode javascript"><code class="sourceCode javascript">        <span class="co">// @param-name for the query field in the </span>
        <span class="co">// request (e.g query/keywords/search)</span>
        <span class="dt">queryAttribute</span>: <span class="ch">&#39;$filter&#39;</span>,

        <span class="co">// @param-name for number of items to return per request/page</span>
        <span class="dt">perPageAttribute</span>: <span class="ch">&#39;$top&#39;</span>,

        <span class="co">// @param-name for how many results the request should skip ahead to</span>
        <span class="dt">skipAttribute</span>: <span class="ch">&#39;$skip&#39;</span>,

        <span class="co">// @param-name for the direction to sort in</span>
        <span class="dt">sortAttribute</span>: <span class="ch">&#39;$sort&#39;</span>,

        <span class="co">// @param-name for field to sort by</span>
        <span class="dt">orderAttribute</span>: <span class="ch">&#39;$orderBy&#39;</span>,

        <span class="co">// @param-name for the format of the request</span>
        <span class="dt">formatAttribute</span>: <span class="ch">&#39;$format&#39;</span>,

        <span class="co">// @param-name for a custom attribute </span>
        <span class="dt">customAttribute1</span>: <span class="ch">&#39;$inlinecount&#39;</span>,

        <span class="co">// @param-name for another custom attribute</span>
        <span class="dt">customAttribute2</span>: <span class="ch">&#39;$callback&#39;</span>,</code></pre><p><strong>Note</strong>: you can define support for new custom attributes in Backbone.Paginator if needed (e.g customAttribute1) for those that may be unique to your service.</p><h4 id="configure-the-default-pagination-query-and-sort-details-for-the-paginator">4. Configure the default pagination, query and sort details for the paginator</h4><p>Now, let's configure the default values in our collection for these parameters so that as a user navigates through the paginated UI, requests are able to continue querying with the correct field to sort on, the right number of items to return per request etc.</p><p>e.g: If we want to request the:</p><ul><li>1st page of results</li><li>for the search query 'superman'</li><li>in JSON format</li><li>sorted by release year</li><li>in ascending order</li><li>where only 30 results are returned per request</li></ul><p>This would look as follows:</p><pre class="sourceCode javascript"><code class="sourceCode javascript">        <span class="co">// current page to query from the service</span>
        <span class="dt">page</span>: <span class="dv">5</span>,

        <span class="co">// The lowest page index your API allows to be accessed</span>
        <span class="dt">firstPage</span>: <span class="dv">0</span>, <span class="co">//some begin with 1</span>

        <span class="co">// how many results to query from the service (i.e how many to return</span>
        <span class="co">// per request)</span>
        <span class="dt">perPage</span>: <span class="dv">30</span>,

        <span class="co">// maximum number of pages that can be queried from </span>
        <span class="co">// the server (only here as a default in case your </span>
        <span class="co">// service doesn&#39;t return the total pages available)</span>
        <span class="dt">totalPages</span>: <span class="dv">10</span>,

        <span class="co">// what field should the results be sorted on?</span>
        <span class="dt">sortField</span>: <span class="ch">&#39;ReleaseYear&#39;</span>,

        <span class="co">// what direction should the results be sorted in?</span>
        <span class="dt">sortDirection</span>: <span class="ch">&#39;asc&#39;</span>,

        <span class="co">// what would you like to query (search) from the service?</span>
        <span class="co">// as Netflix reqires additional parameters around the query</span>
        <span class="co">// we simply fill these around our search term</span>
        <span class="dt">query</span>: <span class="st">&quot;substringof(&#39;&quot;</span> + <span class="fu">escape</span>(<span class="ch">&#39;the&#39;</span>) + <span class="st">&quot;&#39;,Name)&quot;</span>,

        <span class="co">// what format would you like to request results in?</span>
        <span class="dt">format</span>: <span class="ch">&#39;json&#39;</span>,

        <span class="co">// what other custom parameters for the request do </span>
        <span class="co">// you require</span>
        <span class="co">// for your application?</span>
        <span class="dt">customParam1</span>: <span class="ch">&#39;allpages&#39;</span>,

        <span class="dt">customParam2</span>: <span class="ch">&#39;callback&#39;</span>,</code></pre><p>As the particular API we're using requires <code>callback</code> and <code>allpages</code> parameters to also be passed, we simply define the values for these as custom parameters which can be mapped back to requestPager as needed.</p><h4 id="finally-configure-collection.parse-and-were-done">5. Finally, configure Collection.parse() and we're done</h4><p>The last thing we need to do is configure our collection's <code>parse()</code> method. We want to ensure we're returning the correct part of our JSON response containing the data our collection will be populated with, which below is <code>response.d.results</code> (for the Netflix API).</p><p>You might also notice that we're setting <code>this.totalPages</code> to the total page count returned by the API. This allows us to define the maximum number of (result) pages available for the current/last request so that we can clearly display this in the UI. It also allows us to infuence whether clicking say, a 'next' button should proceed with a request or not.</p><pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="dt">parse</span>: <span class="kw">function</span> (response) {
            <span class="co">// Be sure to change this based on how your results</span>
            <span class="co">// are structured (e.g d.results is Netflix specific)</span>
            <span class="kw">var</span> tags = <span class="kw">response.d</span>.<span class="fu">results</span>;
            <span class="co">//Normally this.totalPages would equal response.d.__count</span>
            <span class="co">//but as this particular NetFlix request only returns a</span>
            <span class="co">//total count of items for the search, we divide.</span>
            <span class="kw">this</span>.<span class="fu">totalPages</span> = <span class="kw">Math</span>.<span class="fu">floor</span>(<span class="kw">response.d</span>.__<span class="fu">count</span> / <span class="kw">this</span>.<span class="fu">perPage</span>);
            <span class="kw">return</span> tags;
        }
    });

});</code></pre><h4 id="convenience-methods">Convenience methods:</h4><p>For your convenience, the following methods are made available for use in your views to interact with the <code>requestPager</code>:</p><ul><li><strong>Collection.goTo(n)</strong> - go to a specific page</li><li><strong>Collection.requestNextPage()</strong> - go to the next page</li><li><strong>Collection.requestPreviousPage()</strong> - go to the previous page</li><li><strong>Collection.howManyPer(n)</strong> - set the number of items to display per page</li></ul><h2 id="paginator.clientpager">Paginator.clientPager</h2><p>The <code>clientPager</code> works similar to the <code>requestPager</code>, except that our configuration values influence the pagination of data already returned at a UI-level. Whilst not shown (yet) there is also a lot more UI logic that ties in with the <code>clientPager</code>. An example of this can be seen in â€˜views/clientPagination.js.</p><h4 id="create-a-new-paginated-collection-with-a-model-and-url">1. Create a new paginated collection with a model and URL</h4><p>As with <code>requestPager</code>, let's first create a new Paginated <code>Backbone.Paginator.clientPager</code> collection, with a model and base URL:</p><pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="kw">var</span> PaginatedCollection = <span class="kw">Backbone.Paginator.clientPager</span>.<span class="fu">extend</span>({

        <span class="dt">model</span>: model,

        <span class="dt">url</span>: <span class="ch">&#39;http://odata.netflix.com/v2/Catalog/Titles?&amp;&#39;</span>,</code></pre><h4 id="map-the-attributes-supported-by-your-api-url-1">2. Map the attributes supported by your API (URL)</h4><p>We're similarly going to map request parameter names for your API to those supported in the paginator:</p><pre class="sourceCode javascript"><code class="sourceCode javascript">        <span class="dt">perPageAttribute</span>: <span class="ch">&#39;$top&#39;</span>,

        <span class="dt">skipAttribute</span>: <span class="ch">&#39;$skip&#39;</span>,

        <span class="dt">orderAttribute</span>: <span class="ch">&#39;$orderBy&#39;</span>,

        <span class="dt">customAttribute1</span>: <span class="ch">&#39;$inlinecount&#39;</span>,

        <span class="dt">queryAttribute</span>: <span class="ch">&#39;$filter&#39;</span>,

        <span class="dt">formatAttribute</span>: <span class="ch">&#39;$format&#39;</span>,

        <span class="dt">customAttribute2</span>: <span class="ch">&#39;$callback&#39;</span>,</code></pre><h4 id="configure-how-to-paginate-data-at-a-ui-level">3. Configure how to paginate data at a UI-level</h4><p>We then get to configuration for the paginated data in the UI. <code>perPage</code> specifies how many results to return from the server whilst <code>displayPerPage</code> configures how many of the items in returned results to display per 'page' in the UI. e.g If we request 100 results and only display 20 per page, we have 5 sub-pages of results that can be navigated through in the UI.</p><pre class="sourceCode javascript"><code class="sourceCode javascript">        <span class="co">// M: how many results to query from the service</span>
        <span class="dt">perPage</span>: <span class="dv">40</span>,

        <span class="co">// N: how many results to display per &#39;page&#39; within the UI</span>
        <span class="co">// Effectively M/N = the number of pages the data will be split into.</span>
        <span class="dt">displayPerPage</span>: <span class="dv">20</span>,</code></pre><h4 id="configure-the-rest-of-the-request-parameter-default-values">4. Configure the rest of the request parameter default values</h4><p>We can then configure default values for the rest of our request parameters:</p><pre class="sourceCode javascript"><code class="sourceCode javascript">        <span class="co">// current page to query from the service</span>
        <span class="dt">page</span>: <span class="dv">1</span>,

        <span class="co">// a default. This should be overridden in the collection&#39;s parse()</span>
        <span class="co">// sort direction</span>
        <span class="dt">sortDirection</span>: <span class="ch">&#39;asc&#39;</span>,

        <span class="co">// sort field</span>
        <span class="dt">sortField</span>: <span class="ch">&#39;ReleaseYear&#39;</span>,
        <span class="co">//or year(Instant/AvailableFrom)</span>

        <span class="co">// query</span>
        <span class="dt">query</span>: <span class="st">&quot;substringof(&#39;&quot;</span> + <span class="fu">escape</span>(<span class="ch">&#39;the&#39;</span>) + <span class="st">&quot;&#39;,Name)&quot;</span>,

        <span class="co">// request format</span>
        <span class="dt">format</span>: <span class="ch">&#39;json&#39;</span>,

        <span class="co">// custom parameters for the request that may be specific to your</span>
        <span class="co">// application</span>
        <span class="dt">customParam1</span>: <span class="ch">&#39;allpages&#39;</span>,

        <span class="dt">customParam2</span>: <span class="ch">&#39;callback&#39;</span>,</code></pre><h4 id="finally-configure-collection.parse-and-were-done-1">5. Finally, configure Collection.parse() and we're done</h4><p>And finally we have our <code>parse()</code> method, which in this case isn't concerned with the total number of result pages available on the server as we have our own total count of pages for the paginated data in the UI.</p><pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="dt">parse</span>: <span class="kw">function</span> (response) {
            <span class="kw">var</span> tags = <span class="kw">response.d</span>.<span class="fu">results</span>;
            <span class="kw">return</span> tags;
        }

});</code></pre><h4 id="convenience-methods-1">Convenience methods:</h4><p>As mentioned, your views can hook into a number of convenience methods to navigate around UI-paginated data. For <code>clientPager</code> these include:</p><ul><li><strong>Collection.goTo(n)</strong> - go to a specific page</li><li><strong>Collection.previousPage()</strong> - go to the previous page</li><li><strong>Collection.nextPage()</strong> - go to the next page</li><li><strong>Collection.howManyPer(n)</strong> - set how many items to display per page</li><li><strong>Collection.pager(sortBy, sortDirection)</strong> - update sort on the current view</li></ul><h2 id="viewstemplates">Views/Templates</h2><p>Although the collection layer is perhaps the most important part of Backbone.Paginator, it would be of little use without views interacting with it. The project zipball comes with three complete examples of using the components with the Netflix API, but here's a sample view and template from the <code>requestPager()</code> example for those interested in learning more:</p><p>First, we have a view for a pagination bar in our UI that allows us to navigate around our paginated collection:</p><pre class="sourceCode javascript"><code class="sourceCode javascript">(<span class="kw">function</span> ( views ) {

    <span class="kw">views</span>.<span class="fu">PaginatedView</span> = <span class="kw">Backbone.View</span>.<span class="fu">extend</span>({

        <span class="dt">events</span>: {
            <span class="ch">&#39;click a.servernext&#39;</span>: <span class="ch">&#39;nextResultPage&#39;</span>,
            <span class="ch">&#39;click a.serverprevious&#39;</span>: <span class="ch">&#39;previousResultPage&#39;</span>,
            <span class="ch">&#39;click a.orderUpdate&#39;</span>: <span class="ch">&#39;updateSortBy&#39;</span>,
            <span class="ch">&#39;click a.serverlast&#39;</span>: <span class="ch">&#39;gotoLast&#39;</span>,
            <span class="ch">&#39;click a.page&#39;</span>: <span class="ch">&#39;gotoPage&#39;</span>,
            <span class="ch">&#39;click a.serverfirst&#39;</span>: <span class="ch">&#39;gotoFirst&#39;</span>,
            <span class="ch">&#39;click a.serverpage&#39;</span>: <span class="ch">&#39;gotoPage&#39;</span>,
            <span class="ch">&#39;click .serverhowmany a&#39;</span>: <span class="ch">&#39;changeCount&#39;</span>

        },

        <span class="dt">tagName</span>: <span class="ch">&#39;aside&#39;</span>,

        <span class="dt">template</span>: <span class="kw">_</span>.<span class="fu">template</span>($(<span class="ch">&#39;#tmpServerPagination&#39;</span>).<span class="fu">html</span>()),

        <span class="dt">initialize</span>: <span class="kw">function</span> () {

            <span class="kw">this</span>.<span class="fu">collection</span>.<span class="fu">on</span>(<span class="ch">&#39;reset&#39;</span>, <span class="kw">this</span>.<span class="fu">render</span>, <span class="kw">this</span>);
            <span class="kw">this</span>.<span class="fu">collection</span>.<span class="fu">on</span>(<span class="ch">&#39;change&#39;</span>, <span class="kw">this</span>.<span class="fu">render</span>, <span class="kw">this</span>);
            <span class="kw">this</span>.$<span class="fu">el</span>.<span class="fu">appendTo</span>(<span class="ch">&#39;#pagination&#39;</span>);

        },

        <span class="dt">render</span>: <span class="kw">function</span> () {
            <span class="kw">var</span> html = <span class="kw">this</span>.<span class="fu">template</span>(<span class="kw">this</span>.<span class="fu">collection</span>.<span class="fu">info</span>());
            <span class="kw">this</span>.$<span class="fu">el</span>.<span class="fu">html</span>(html);
        },

        <span class="dt">updateSortBy</span>: <span class="kw">function</span> (e) {
            <span class="kw">e</span>.<span class="fu">preventDefault</span>();
            <span class="kw">var</span> currentSort = $(<span class="ch">&#39;#sortByField&#39;</span>).<span class="fu">val</span>();
            <span class="kw">this</span>.<span class="fu">collection</span>.<span class="fu">updateOrder</span>(currentSort);
        },

        <span class="dt">nextResultPage</span>: <span class="kw">function</span> (e) {
            <span class="kw">e</span>.<span class="fu">preventDefault</span>();
            <span class="kw">this</span>.<span class="fu">collection</span>.<span class="fu">requestNextPage</span>();
        },

        <span class="dt">previousResultPage</span>: <span class="kw">function</span> (e) {
            <span class="kw">e</span>.<span class="fu">preventDefault</span>();
            <span class="kw">this</span>.<span class="fu">collection</span>.<span class="fu">requestPreviousPage</span>();
        },

        <span class="dt">gotoFirst</span>: <span class="kw">function</span> (e) {
            <span class="kw">e</span>.<span class="fu">preventDefault</span>();
            <span class="kw">this</span>.<span class="fu">collection</span>.<span class="fu">goTo</span>(<span class="kw">this</span>.<span class="fu">collection</span>.<span class="fu">information</span>.<span class="fu">firstPage</span>);
        },

        <span class="dt">gotoLast</span>: <span class="kw">function</span> (e) {
            <span class="kw">e</span>.<span class="fu">preventDefault</span>();
            <span class="kw">this</span>.<span class="fu">collection</span>.<span class="fu">goTo</span>(<span class="kw">this</span>.<span class="fu">collection</span>.<span class="fu">information</span>.<span class="fu">lastPage</span>);
        },

        <span class="dt">gotoPage</span>: <span class="kw">function</span> (e) {
            <span class="kw">e</span>.<span class="fu">preventDefault</span>();
            <span class="kw">var</span> page = $(<span class="kw">e</span>.<span class="fu">target</span>).<span class="fu">text</span>();
            <span class="kw">this</span>.<span class="fu">collection</span>.<span class="fu">goTo</span>(page);
        },

        <span class="dt">changeCount</span>: <span class="kw">function</span> (e) {
            <span class="kw">e</span>.<span class="fu">preventDefault</span>();
            <span class="kw">var</span> per = $(<span class="kw">e</span>.<span class="fu">target</span>).<span class="fu">text</span>();
            <span class="kw">this</span>.<span class="fu">collection</span>.<span class="fu">howManyPer</span>(per);
        }

    });

})( <span class="kw">app</span>.<span class="fu">views</span> );</code></pre><p>which we use with a template like this to generate the necessary pagination links (more are shown in the full example):</p><pre class="sourceCode html"><code class="sourceCode html"><span class="kw">&lt;span</span><span class="ot"> class=</span><span class="st">&quot;divider&quot;</span><span class="kw">&gt;</span>/<span class="kw">&lt;/span&gt;</span>  
        <span class="er">&lt;</span>% if (page &gt; firstPage) { %&gt;  
            <span class="kw">&lt;a</span><span class="ot"> href=</span><span class="st">&quot;#&quot;</span><span class="ot"> class=</span><span class="st">&quot;serverprevious&quot;</span><span class="kw">&gt;</span>Previous<span class="kw">&lt;/a&gt;</span>  
        <span class="er">&lt;</span>% }else{ %&gt;  
            <span class="kw">&lt;span&gt;</span>Previous<span class="kw">&lt;/span&gt;</span>  
        <span class="er">&lt;</span>% }%&gt;  
        <span class="er">&lt;</span>% if (page <span class="er">&lt;</span> totalPages) { %&gt;  
            <span class="kw">&lt;a</span><span class="ot"> href=</span><span class="st">&quot;#&quot;</span><span class="ot"> class=</span><span class="st">&quot;servernext&quot;</span><span class="kw">&gt;</span>Next<span class="kw">&lt;/a&gt;</span>  
        <span class="er">&lt;</span>% } %&gt;  
        <span class="er">&lt;</span>% if (firstPage != page) { %&gt;  
            <span class="kw">&lt;a</span><span class="ot"> href=</span><span class="st">&quot;#&quot;</span><span class="ot"> class=</span><span class="st">&quot;serverfirst&quot;</span><span class="kw">&gt;</span>First<span class="kw">&lt;/a&gt;</span>  
        <span class="er">&lt;</span>% } %&gt;  
        <span class="er">&lt;</span>% if (lastPage != page) { %&gt;  
            <span class="kw">&lt;a</span><span class="ot"> href=</span><span class="st">&quot;#&quot;</span><span class="ot"> class=</span><span class="st">&quot;serverlast&quot;</span><span class="kw">&gt;</span>Last<span class="kw">&lt;/a&gt;</span>  
        <span class="er">&lt;</span>% } %&gt;  
        <span class="kw">&lt;span</span><span class="ot"> class=</span><span class="st">&quot;divider&quot;</span><span class="kw">&gt;</span>/<span class="kw">&lt;/span&gt;</span>  
        <span class="kw">&lt;span</span><span class="ot"> class=</span><span class="st">&quot;cell serverhowmany&quot;</span><span class="kw">&gt;</span>  
            Show  
            <span class="kw">&lt;a</span><span class="ot"> href=</span><span class="st">&quot;#&quot;</span><span class="ot"> class=</span><span class="st">&quot;selected&quot;</span><span class="kw">&gt;</span>3<span class="kw">&lt;/a&gt;</span>  
            |  
            <span class="kw">&lt;a</span><span class="ot"> href=</span><span class="st">&quot;#&quot;</span><span class="ot"> class=</span><span class="st">&quot;&quot;</span><span class="kw">&gt;</span>9<span class="kw">&lt;/a&gt;</span>  
            |  
            <span class="kw">&lt;a</span><span class="ot"> href=</span><span class="st">&quot;#&quot;</span><span class="ot"> class=</span><span class="st">&quot;&quot;</span><span class="kw">&gt;</span>12<span class="kw">&lt;/a&gt;</span>  
            per page  
        <span class="kw">&lt;/span&gt;</span>  
        <span class="kw">&lt;span</span><span class="ot"> class=</span><span class="st">&quot;divider&quot;</span><span class="kw">&gt;</span>/<span class="kw">&lt;/span&gt;</span>  
        <span class="kw">&lt;span</span><span class="ot"> class=</span><span class="st">&quot;cell first records&quot;</span><span class="kw">&gt;</span>  
            Page: <span class="kw">&lt;span</span><span class="ot"> class=</span><span class="st">&quot;current&quot;</span><span class="kw">&gt;</span><span class="er">&lt;</span>%= page %&gt;<span class="kw">&lt;/span&gt;</span>  
            of  
            <span class="kw">&lt;span</span><span class="ot"> class=</span><span class="st">&quot;total&quot;</span><span class="kw">&gt;</span><span class="er">&lt;</span>%= totalPages %&gt;<span class="kw">&lt;/span&gt;</span>  
                        shown  
        <span class="kw">&lt;/span&gt;</span>  
<span class="kw">&lt;span</span><span class="ot"> class=</span><span class="st">&quot;divider&quot;</span><span class="kw">&gt;</span>/<span class="kw">&lt;/span&gt;</span>  
    <span class="kw">&lt;span</span><span class="ot"> class=</span><span class="st">&quot;cell sort&quot;</span><span class="kw">&gt;</span>  
        <span class="kw">&lt;a</span><span class="ot"> href=</span><span class="st">&quot;#&quot;</span><span class="ot"> class=</span><span class="st">&quot;orderUpdate btn small&quot;</span><span class="kw">&gt;</span>Sort by:<span class="kw">&lt;/a&gt;</span>  
    <span class="kw">&lt;/span&gt;</span>  
    <span class="kw">&lt;select</span><span class="ot"> id=</span><span class="st">&quot;sortByField&quot;</span><span class="kw">&gt;</span>  
        <span class="kw">&lt;option</span><span class="ot"> value=</span><span class="st">&quot;cid&quot;</span><span class="kw">&gt;</span>Select a field to sort on<span class="kw">&lt;/option&gt;</span>  
        <span class="kw">&lt;option</span><span class="ot"> value=</span><span class="st">&quot;ReleaseYear&quot;</span><span class="kw">&gt;</span>Release year<span class="kw">&lt;/option&gt;</span>  
        <span class="kw">&lt;option</span><span class="ot"> value=</span><span class="st">&quot;ShortName&quot;</span><span class="kw">&gt;</span>Alphabetical<span class="kw">&lt;/option&gt;</span>  
    <span class="kw">&lt;/select&gt;</span>  
<span class="kw">&lt;/span&gt;</span>  </code></pre><h2 id="backbone-jquery-mobile">Backbone &amp; jQuery Mobile</h2><h3 id="resolving-the-routing-conflicts">Resolving the routing conflicts</h3><p>The first major hurdle developers typically run into when building Backbone applications with jQuery Mobile is that both frameworks have their own opinions about how to handle application navigation.</p><p>Backbone's routers offer an explicit way to define custom navigation routes through <code>Backbone.Router</code>, whilst jQuery Mobile encourages the use of URL hash fragments to reference separate 'pages' or views in the same document. jQuery Mobile also supports automatically pulling in external content for links through XHR calls meaning that there can be quite a lot of inter-framework confusion about what a link pointing at '#photo/id' should actually be doing.</p><p>Some of the solutions that have been previously proposed to work-around this problem included manually patching Backbone or jQuery Mobile. I discourage opting for these techniques as it becomes necessary to manually patch your framework builds when new releases get made upstream.</p><p>There's also <a href="https://github.com/azicchetti/jquerymobile-router">jQueryMobile router</a>, which tries to solve this problem differently, however I think my proposed solution is both simpler and allows both frameworks to cohabit quite peacefully without the need to extend either. What we're after is a way to prevent one framework from listening to hash changes so that we can fully rely on the other (e.g. <code>Backbone.Router</code>) to handle this for us exclusively.</p><p>Using jQuery Mobile this can be done by setting:</p><pre class="sourceCode javascript"><code class="sourceCode javascript">$.<span class="fu">mobile</span>.<span class="fu">hashListeningEnabled</span> = <span class="kw">false</span>;</code></pre><p>prior to initializing any of your other code.</p><p>I discovered this method looking through some jQuery Mobile commits that didn't make their way into the official docs, but am happy to see that they are now covered here http://jquerymobile.com/test/docs/api/globalconfig.html in more detail.</p><p>The next question that arises is, if we're preventing jQuery Mobile from listening to URL hash changes, how can we still get the benefit of being able to navigate to other sections in a document using the built-in transitions and effects supported? Good question. This can now be solve by simply calling <code>$.mobile.changePage()</code> as follows:</p><pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="kw">var</span> url = <span class="ch">&#39;#about&#39;</span>,
    effect = <span class="ch">&#39;slideup&#39;</span>,
    reverse = <span class="kw">false</span>,
    changeHash = <span class="kw">false</span>;

$.<span class="fu">mobile</span>.<span class="fu">changePage</span>( url , { <span class="dt">transition</span>: effect}, reverse, changeHash );</code></pre><p>In the above sample, <code>url</code> can refer to a URL or a hash identifier to navigate to, <code>effect</code> is simply the transition effect to animate the page in with and the final two parameters decide the direction for the transition (<code>reverse</code>) and whether or not the hash in the address bar should be updated (<code>changeHash</code>). With respect to the latter, I typically set this to false to avoid managing two sources for hash updates, but feel free to set this to true if you're comfortable doing so.</p><p><strong>Note:</strong> For some parallel work being done to explore how well the jQuery Mobile Router plugin works with Backbone, you may be interested in checking out https://github.com/Filirom1/jquery-mobile-backbone-requirejs.</p><h3 id="practical-a-backbone-requirejsamd-app-with-jquery-mobile">Practical: A Backbone, RequireJS/AMD app with jQuery Mobile</h3><p><strong>Note:</strong> The code for this practical can be found in <code>practicals/modular-mobile-app</code>.</p><h3 id="getting-started">Getting started</h3><p>Once you feel comfortable with the <a href="http://msdn.microsoft.com/en-us/scriptjunkie/hh377172.aspx">Backbone fundamentals</a> and you've put together a rough wireframe of the app you may wish to build, start to think about your application architecture. Ideally, you'll want to logically separate concerns so that it's as easy as possible to maintain the app in the future.</p><p><strong>Namespacing</strong></p><p>For this application, I opted for the nested namespacing pattern. Implemented correctly, this enables you to clearly identify if items being referenced in your app are views, other modules and so on. This initial structure is a sane place to also include application defaults (unless you prefer maintaining those in a separate file).</p><pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="kw">window</span>.<span class="fu">mobileSearch</span> = <span class="kw">window</span>.<span class="fu">mobileSearch</span> || {
    <span class="dt">views</span>: {
        <span class="dt">appview</span>: <span class="kw">new</span> AppView
    },
    <span class="dt">routers</span>:{
        <span class="dt">workspace</span>:<span class="kw">new</span> Workspace()
    },
    <span class="dt">utils</span>: utils,
    <span class="dt">defaults</span>:{
        <span class="dt">resultsPerPage</span>: <span class="dv">16</span>,
        <span class="dt">safeSearch</span>: <span class="dv">2</span>,
        <span class="dt">maxDate</span>:<span class="ch">&#39;&#39;</span>,
        <span class="dt">minDate</span>:<span class="ch">&#39;01/01/1970&#39;</span>
    }
}</code></pre><p><strong>Models</strong></p><p>In the Flickly application, there are at least two unique types of data that need to be modeled - search results and individual photos, both of which contain additional meta-data like photo titles. If you simplify this down, search results are actually groups of photos in their own right, so the application only requires:</p><ul><li>A single model (a photo or 'result' entry)</li><li>A result collection (containing a group of result entries) for search results</li><li>A photo collection (containing one or more result entries) for individual photos or photos with more than one image</li></ul><p><strong>Views</strong></p><p>The views we'll need include an application view, a search results view and a photo view. Static views or pages of the single-page application which do not require a dynamic element to them (e.g an 'about' page) can be easily coded up in your document's markup, independent of Backbone.</p><p><strong>Routers</strong></p><p>A number of possible routes need to be taken into consideration:</p><ul><li>Basic search queries <code>#search/kiwis</code></li><li>Search queries with additional parameters (e.g sort, pagination) <code>#search/kiwis/srelevance/p7</code></li><li>Queries for specific photos <code>#photo/93839</code></li><li>A default route (no parameters passed)</li></ul><p>This tutorial will be expanded shortly to fully cover the demo application. In the mean time, please see the practicals folder for the completed application that demonstrates the router resolution discussed earlier between Backbone and jQuery Mobile.</p><h3 id="jquery-mobile-going-beyond-mobile-application-development">jQuery Mobile: Going beyond mobile application development</h3><p>The majority of jQM apps I've seen in production have been developed for the purpose of providing an optimal experience to users on mobile devices. Given that the framework was developed for this purpose, there's nothing fundamentally wrong with this, but many developers forget that jQM is a UI framework not dissimilar to jQuery UI. It's using the widget factory and is capable of being used for a lot more than we give it credit for.</p><p>If you open up Flickly in a desktop browser, you'll get an image search UI that's modeled on Google.com, however, review the components (buttons, text inputs, tabs) on the page for a moment. The desktop UI doesn't look anything like a mobile application yet I'm still using jQM for theming mobile components; the tabs, date-picker, sliders - everything in the desktop UI is re-using what jQM would be providing users on mobile devices. Thanks to some media queries, the desktop UI can make optimal use of whitespace, expanding component blocks out and providing alternative layouts whilst still making use of jQM as a component framework.</p><p>The benefit of this is that I don't need to go pulling in jQuery UI separately to be able to take advantage of these features. Thanks to the recent ThemeRoller my components can look pretty much exactly how I would like them to and users of the app can get a jQM UI for lower-resolutions and a jQM-ish UI for everything else.</p><p>The takeaway here is just to remember that if you're not (already) going through the hassle of conditional script/style loading based on screen-resolution (using matchMedia.js etc), there are simpler approaches that can be taken to cross-device component theming.</p><h2 id="unit-testing"><a name="testing">Unit Testing</a></h2>
</body>
</html>

