<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>MongoDB Ruby Driver</title>
<link href="stylesheet.css" type="text/css" rel="stylesheet" />
</head>
<body>
<h1>MongoDB Ruby Driver</h1>
<h2 id="getting-started">Getting started</h2><p>Once the MongoDB Ruby driver is installed, we can begin to use it to connect to a Mongo database. To create a connection using localhost, we simply specify the driver as a dependency. Assuming we're using the default port we can then connect as follows:</p><pre class="sourceCode ruby"><code class="sourceCode ruby">require <span class="st">&#39;mongo&#39;</span>

<span class="co"># where &#39;learning-mongo&#39; is the name of our database:</span>
db = <span class="dt">Connection</span>.new.db(<span class="st">&#39;learning-mongo&#39;</span>);</code></pre><p>We probably also want to place some data into 'learning-mongo'. It could be as simple as a note, so why don't we go ahead and begin a notes collection?:</p><p><code>ruby notes = db.collection('notes')</code> Something interesting worth noting is that at this point, we haven't actually created the database nor the collection we're referencing above.</p><p>Neither of these items exist in Mongo (just yet) but as we're working with a new database but they will once we insert some real data.</p><p>A new note could be defined using key/value pairs as follows and then inserted into 'learning-mongo' using <code>collection.insert()</code>:</p><pre class="sourceCode ruby"><code class="sourceCode ruby">our_note = { <span class="st">:text</span> =&gt; <span class="st">&#39;Remember the milk&#39;</span>, <span class="st">:remindInterval</span> =&gt; <span class="st">&#39;weekly&#39;</span>}
note_id = notes.insert(our_note)</code></pre><p>What is returned from inserting a note into the notes collection is an <code>ObjectId</code> reference for the note from Mongo. This is useful as we can re-use it to locate the same document in our database.</p><pre class="sourceCode ruby"><code class="sourceCode ruby">note = notes.find( <span class="st">:id</span> =&gt; note_id ).first</code></pre><p>This can also be used in conjunction with Mongo's <code>collection.update()</code> method and <a href="http://www.mongodb.org/display/DOCS/Updating">query</a> operators (i.e <code>$set</code>) to replace fields in an existing document.</p><p>We might update an entire document as follows:</p><pre class="sourceCode ruby"><code class="sourceCode ruby">note = notes.find( <span class="st">:id</span> =&gt; note_id ).first
note[<span class="st">:text</span>] = <span class="st">&#39;Remember the bread&#39;</span>
notes.update({ <span class="st">:_id</span> =&gt; note_id }, note)</code></pre><p>or using <code>$set</code>, update an existing document without overwriting the entire object as like this:</p><pre class="sourceCode ruby"><code class="sourceCode ruby">notes.update({ <span class="st">:_id</span> =&gt; note_id }, <span class="st">&#39;$set&#39;</span> =&gt; { <span class="st">:text</span> = &gt; <span class="st">&#39;Remember the bread&#39;</span> })</code></pre><p>Useful to know: Almost each MongoDB document has an _id field as it's first attribute. This can normally be of any type, however a special BSON datatype is provided for object ids. It's a 12-byte binary value that has a high probability of being unique when allocated.</p><p>Note: Whilst we opted for the MongoDB Ruby Driver for this stack, you may also be interested in <strong>DataMapper</strong> - a solution which allows us to use the same API to talk to a number of different datastores. This works well for both relational and non-relational databases and more information is available on the official <a href="http://datamapper.org/why.html">project page</a>. <a href="http://sinatra-book.gittr.com/#datamapper">Sinatra: The Book</a> also contains a brief tutorial on DataMapper for anyone interested in exploring it further.</p>
</body>
</html>

